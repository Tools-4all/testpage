<script src="{% static 'js/errorComponent.js' %}"></script>
<script>
  const removedImgBtn = document.getElementById("removedImgBtn");
  const hiddenDiv = document.getElementById("hiddenDiv");
  const dragBox = document.getElementById("dragBox");
  const uploadFileInput = document.getElementById("uploadFile");
  const modelLoadingEl = document.getElementById("modelLoading");
  const downloadBtn = document.getElementById("downloadBtn");
  const previewImg = document.getElementById("previewImage");
  const colorsDiv = document.getElementById("colorsDiv");

  let finalDataUrl = null;
  let file;
  let worker;
  let isProcessing = false;

  const modelPath = "https://huggingface.co/tools-4all/bg_remover/resolve/main/bg_remover.onnx";
  const cacheName = "bg-remover-model-cache";
  const modelCacheKey = "bg-remover-model";

  // Initialize Web Worker
  function initWorker() {
    worker = new Worker("{% static 'js/bgRemovalWorker.js' %}");
    worker.onmessage = (e) => {
      console.log("Main: Received message from worker:", e.data);
      const { type, data, error } = e.data;
      if (type === "result") {
        console.log("Main: Processing result with dataURL:", data);
        handleWorkerResult(data);
      } else if (type === "error") {
        console.log("Main: Worker error:", error);
        handleWorkerError(error);
      } else if (type === "modelLoaded") {
        console.log("Main: Model loaded in worker");
        stopSpinner();
      }
    };
    worker.onerror = (error) => {
      console.error("Main: Worker error event:", {
        message: error.message,
        filename: error.filename,
        lineno: error.lineno,
        colno: error.colno,
        error: error
      });
      handleWorkerError("Worker failed: " + (error.message || "Unknown error"));
    };
  }

  // Preload and cache the model
  async function preloadModel() {
    try {
      const cache = await caches.open(cacheName);
      const cachedResponse = await cache.match(modelCacheKey);
      if (cachedResponse) {
        console.log("Model found in cache");
        const blob = await cachedResponse.blob();
        worker.postMessage({ type: "loadModel", modelUrl: URL.createObjectURL(blob) });
        return;
      }

      console.log("Fetching model...");
      const response = await fetch(modelPath);
      if (!response.ok) throw new Error("Failed to fetch model");

      const responseToCache = response.clone();
      await cache.put(modelCacheKey, responseToCache);

      const blob = await response.blob();
      worker.postMessage({ type: "loadModel", modelUrl: URL.createObjectURL(blob) });
    } catch (err) {
      console.error("Model preload failed:", err);
      showError("Failed to preload the model");
      stopSpinner();
    }
  }

  // Stop spinner and show main content
  function stopSpinner() {
    const spinnerDiv = document.getElementById("spinner");
    const spinner = document.querySelector(".spinner img");

    spinner.classList.remove("spin-active");
    spinnerDiv.style.display = "none";
    document.getElementById("mainDiv").style.display = "flex";
  }

  // Initialize on page load
  window.addEventListener("load", () => {
    console.log("Main: Initializing worker and preloading model");
    initWorker();
    preloadModel();
  });

  // Drag and drop overlay
  const overlay = document.createElement("div");
  overlay.id = "dropOverlay";
  const overlayText = document.createElement("h2");
  overlayText.textContent = "Drop anywhere you want";
  overlay.appendChild(overlayText);
  document.body.appendChild(overlay);

  document.addEventListener("dragover", (event) => {
    event.preventDefault();
    overlay.style.display = "flex";
  });

  document.addEventListener("dragleave", (event) => {
    if (event.relatedTarget === null || event.relatedTarget.nodeName === "HTML") {
      overlay.style.display = "none";
    }
  });

  document.addEventListener("drop", async (event) => {
    event.preventDefault();
    overlay.style.display = "none";

    const files = event.dataTransfer.files;
    if (files.length) {
      const file = files[0];
      console.log("Main: Dropped file:", file.name);
      await handleFileSelect(file, true);
    }
  });

  // Read file as Data URL
  function readFileAsDataURL(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = (err) => reject(err);
      reader.readAsDataURL(file);
    });
  }

  // Display images
  function displayImages(originalSrc) {
    console.log("Main: Displaying original image");
    // Clear previous content
    while (previewImg.firstChild) {
      previewImg.removeChild(previewImg.firstChild);
    }

    const imageContainer = document.createElement("div");
    imageContainer.classList.add("imageContainer");
    imageContainer.style.position = "relative";
    imageContainer.style.width = "100%";
    imageContainer.style.height = "auto";

    const originalImgEl = document.createElement("img");
    originalImgEl.src = originalSrc;
    originalImgEl.classList.add("img-original");
    originalImgEl.style.maxWidth = "100%";
    originalImgEl.style.display = "block";

    const removedImgEl = document.createElement("img");
    removedImgEl.classList.add("removedImg");
    removedImgEl.style.maxWidth = "100%";
    removedImgEl.style.display = "none"; // Initially hidden
    removedImgEl.style.position = "absolute";
    removedImgEl.style.top = "0";
    removedImgEl.style.left = "0";

    const starsContainer = document.createElement("div");
    starsContainer.classList.add("stars-container");
    starsContainer.style.position = "absolute";
    starsContainer.style.top = "0";
    starsContainer.style.left = "0";
    starsContainer.style.width = "100%";
    starsContainer.style.height = "100%";
    createStars(starsContainer);

    imageContainer.appendChild(originalImgEl);
    imageContainer.appendChild(removedImgEl);
    imageContainer.appendChild(starsContainer);
    previewImg.appendChild(imageContainer);

    dragBox.style.display = "none";
    previewImg.style.display = "block";
    document.getElementById('title').style.display = "none";

    return removedImgEl;
  }

  // Handle file selection
  async function handleFileSelect(e, isFile = false) {
    if (isProcessing) {
      showError("Please wait, processing is already in progress.");
      return;
    }
    isProcessing = true;
    file = isFile ? e : (e.target.files || e.dataTransfer.files)[0];
    if (!file) {
      console.log("Main: No file selected");
      isProcessing = false;
      return;
    }

    const allowedTypes = ["image/jpeg", "image/png", "image/webp", "image/gif", "image/bmp", "image/svg+xml", "image/vnd.microsoft.icon"];
    if (!allowedTypes.includes(file.type)) {
      showError("Unsupported file type. Please upload a valid image.");
      console.log("Main: Unsupported file type:", file.type);
      isProcessing = false;
      return;
    }

    try {
      console.log("Main: Handling file:", file.name);
      const originalDataURL = await readFileAsDataURL(file);
      const removedImgEl = displayImages(originalDataURL);

      startStarsAnimation(true);
      modelLoadingEl.classList.add("show");

      const arrayBuffer = await file.arrayBuffer();
      console.log("Main: Sending file to worker, arrayBuffer size:", arrayBuffer.byteLength);
      worker.postMessage(
        { type: "removeBg", arrayBuffer: arrayBuffer, fileName: file.name, fileType: file.type },
        [arrayBuffer]
      );

      removedImgEl.onerror = () => {
        console.error("Main: Failed to load background-removed image");
        showError("Failed to load the background-removed image.");
        removeImage();
        isProcessing = false;
      };
    } catch (err) {
      console.error("Main: Error in handleFileSelect:", err);
      showError("Failed to remove background");
      removeImage();
      isProcessing = false;
    }
  }

  // Handle Web Worker result
  function handleWorkerResult(dataURL) {
    console.log("Main: Handling worker result, dataURL length:", dataURL ? dataURL.length : "null");
    startStarsAnimation(false);
    modelLoadingEl.classList.remove("show");

    const removedImgEl = previewImg.querySelector(".removedImg");
    const originalImgEl = previewImg.querySelector(".img-original");
    if (!removedImgEl || !originalImgEl) {
      console.error("Main: Image elements not found");
      showError("Failed to find image elements");
      removeImage();
      isProcessing = false;
      return;
    }

    if (!dataURL || typeof dataURL !== "string" || !dataURL.startsWith("data:image/png")) {
      console.error("Main: Invalid dataURL received:", dataURL);
      showError("Invalid background-removed image data");
      removeImage();
      isProcessing = false;
      return;
    }

    finalDataUrl = dataURL;
    removedImgEl.src = dataURL;
    removedImgEl.onload = () => {
      console.log("Main: Background-removed image loaded successfully");
      originalImgEl.style.display = "none";
      removedImgEl.style.display = "block";
      removedImgBtn.style.display = "block";
      hiddenDiv.style.display = "flex";
      isProcessing = false;
    };
    removedImgEl.onerror = () => {
      console.error("Main: Failed to load background-removed image");
      showError("Failed to load the background-removed image");
      removeImage();
      isProcessing = false;
    };
  }

  // Handle Web Worker error
  function handleWorkerError(error) {
    console.error("Main: Handling worker error:", error);
    startStarsAnimation(false);
    modelLoadingEl.classList.remove("show");
    showError(error);
    removeImage();
    isProcessing = false;
  }

  // Remove image
  function removeImage() {
    console.log("Main: Removing image");
    document.getElementById('title').style.display = "block";
    dragBox.style.display = "flex";
    previewImg.style.display = "none";
    removedImgBtn.style.display = "none";
    hiddenDiv.style.display = "none";
    uploadFileInput.value = "";
    finalDataUrl = null;

    while (previewImg.firstChild) {
      previewImg.removeChild(previewImg.firstChild);
    }

    if (colorsDiv.style.display === "block") {
      colorsDiv.style.display = "none";
    }
  }

  // Download button
  downloadBtn.addEventListener("click", async () => {
    if (!finalDataUrl) {
      console.log("Main: No image to download");
      return;
    }
    console.log("Main: Downloading image");
    const removedImgEl = previewImg.querySelector(".removedImg");
    const imageContainer = previewImg.querySelector(".imageContainer");

    if (!removedImgEl || !imageContainer) {
      console.error("Main: Elements not found for download");
      return;
    }

    // Create a canvas
    const canvas = document.createElement("canvas");
    canvas.width = removedImgEl.naturalWidth;
    canvas.height = removedImgEl.naturalHeight;
    const ctx = canvas.getContext("2d");

    // Draw background
    const bgColor = imageContainer.style.backgroundColor;
    const bgImage = imageContainer.style.backgroundImage;

    if (bgImage && bgImage !== "none") {
      // Draw background image
      const bgImg = new Image();
      bgImg.src = bgImage.slice(4, -1).replace(/"/g, ""); // Extract URL from url("...")
      await new Promise((resolve) => {
        bgImg.onload = resolve;
      });
      ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
    } else if (bgColor) {
      // Draw background color
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Draw the removed image
    const img = new Image();
    img.src = finalDataUrl;
    await new Promise((resolve) => {
      img.onload = resolve;
    });
    ctx.drawImage(img, 0, 0);

    // Get data URL
    const compositedDataUrl = canvas.toDataURL("image/png");

    // Download
    const a = document.createElement("a");
    a.href = compositedDataUrl;
    a.download = "bg_removed.png";
    document.body.appendChild(a);
    a.click();
    a.remove();
  });

  // Stars animation
  function startStarsAnimation(run) {
    const starsContainer = document.querySelector(".stars-container");
    if (!starsContainer) {
      console.log("Main: Stars container not found");
      return;
    }
    if (run) {
      console.log("Main: Starting stars animation");
      starsContainer.style.display = "block";
      const stars = starsContainer.querySelectorAll(".star");
      stars.forEach(star => {
        star.style.animationPlayState = "running";
      });
    } else {
      console.log("Main: Stopping stars animation");
      const stars = starsContainer.querySelectorAll(".star");
      stars.forEach(star => {
        star.style.animationPlayState = "paused";
      });
      starsContainer.style.display = "none";
    }
  }

  function createStars(parentEl) {
    console.log("Main: Creating stars");
    const totalStars = 15;
    const gridSize = Math.sqrt(totalStars);
    const starPositions = [];

    parentEl.style.display = "block";

    for (let i = 0; i < totalStars; i++) {
      const star = document.createElement("div");
      star.classList.add("star");

      const row = Math.floor(i / gridSize);
      const col = i % gridSize;

      const cellWidth = 100 / gridSize;
      const cellHeight = 100 / gridSize;

      const minTop = row * cellHeight;
      const maxTop = minTop + cellHeight;
      const minLeft = col * cellWidth;
      const maxLeft = minLeft + cellWidth;

      const topPos = Math.random() * (maxTop - minTop) + minTop;
      const leftPos = Math.random() * (maxLeft - minLeft) + minLeft;

      starPositions.push([topPos, leftPos]);

      star.style.top = `${topPos}%`;
      star.style.left = `${leftPos}%`;
      star.style.animationDuration = `${Math.random() * 2 + 1}s`;

      parentEl.appendChild(star);

      setTimeout(() => {
        star.remove();
      }, 3000);
    }
  }

  // Change background color
  function displayColors() {
    console.log("Main: Toggling colors div");
    if (colorsDiv.style.display === "block") {
      hiddenDiv.style.display = "flex";
      colorsDiv.style.display = "none";
    } else {
      hiddenDiv.style.display = "none";
      colorsDiv.style.display = "block";
    }
  }

  const closeColorsDiv = document.getElementById("closeColorsDiv");
  closeColorsDiv.addEventListener("click", () => {
    console.log("Main: Closing colors div");
    hiddenDiv.style.display = "flex";
    colorsDiv.style.display = "none";
  });

  function removeHighlight() {
    document.querySelectorAll(".colorBtn, #colorPreview").forEach(button => {
      button.style.boxShadow = "none";
    });
  }

  document.querySelectorAll(".colorBtn").forEach(button => {
    button.addEventListener("click", () => {
      console.log("Main: Color button clicked:", button.style.backgroundColor);
      removeHighlight();
      button.style.boxShadow = "#71b8fb 0px 0px 15px 3px";
      const imageContainer = previewImg.querySelector(".imageContainer");
      if (imageContainer) {
        imageContainer.style.backgroundColor = button.style.backgroundColor;
        imageContainer.style.backgroundImage = ""; // Reset background image
      }
    });
  });

  const customColorInput = document.getElementById("customColor");
  const colorPreview = document.getElementById("colorPreview");

  customColorInput.addEventListener("input", () => {
    console.log("Main: Custom color selected:", customColorInput.value);
    removeHighlight();
    colorPreview.style.boxShadow = "#71b8fb 0px 0px 15px 3px";
    colorPreview.style.backgroundColor = customColorInput.value;
    const imageContainer = previewImg.querySelector(".imageContainer");
    if (imageContainer) {
      imageContainer.style.backgroundColor = customColorInput.value;
      imageContainer.style.backgroundImage = ""; // Reset background image
    }
    colorPreview.textContent = "";
  });

  // Upload background image
  document.getElementById("uploadSection").addEventListener("click", () => {
    console.log("Main: Opening background image uploader");
    const imageUploader = document.getElementById("imageUploader");
    imageUploader.click();
  });

  const imageUploader = document.getElementById("imageUploader");
  imageUploader.addEventListener("change", async (e) => {
    const bgFile = e.target.files[0];
    if (!bgFile) return;

    try {
      const bgDataURL = await readFileAsDataURL(bgFile);
      const imageContainer = previewImg.querySelector(".imageContainer");
      if (imageContainer) {
        imageContainer.style.backgroundImage = `url(${bgDataURL})`;
        imageContainer.style.backgroundSize = "cover";
        imageContainer.style.backgroundPosition = "center";
        imageContainer.style.backgroundColor = ""; // Reset background color
      }
    } catch (err) {
      console.error("Main: Error uploading background image:", err);
      showError("Failed to upload background image");
    }
  });

  function showError(msg) {
    console.log("Main: Showing error:", msg);
    alert(msg);
  }
</script>

<script>
  // Web Worker Script embedded as a data URL
  const workerScript = `
    try {
        importScripts("https://cdn.jsdelivr.net/npm/onnxruntime-web@1.15.0/dist/ort.min.js");
        console.log("Worker: Successfully imported onnxruntime-web");
    } catch (err) {
        console.error("Worker: Failed to import onnxruntime-web:", err);
        self.postMessage({ type: "error", error: "Failed to load ONNX runtime: " + err.message });
    }

    let session = null;

    self.onmessage = async (e) => {
        console.log("Worker: Received message:", e.data);
        const { type, modelUrl, arrayBuffer, fileName, fileType } = e.data;
        ort.env.wasm.wasmPaths = "https://cdn.jsdelivr.net/npm/onnxruntime-web@1.15.0/dist/";
        if (type === "loadModel") {
            try {
                console.log("Worker: Loading model from:", modelUrl);
                if (!modelUrl) throw new Error("Model URL is undefined");
                session = await ort.InferenceSession.create(modelUrl, { executionProviders: ["wasm"] });
                console.log("Worker: Model loaded successfully");
                self.postMessage({ type: "modelLoaded" });
            } catch (err) {
                console.error("Worker: Failed to load model:", err);
                self.postMessage({ type: "error", error: "Failed to load the model: " + err.message });
            }
        } else if (type === "removeBg") {
            try {
                if (!session) {
                    console.error("Worker: Model not loaded");
                    self.postMessage({ type: "error", error: "Model not loaded" });
                    return;
                }
                console.log("Worker: Validating input data");
                if (!arrayBuffer || !(arrayBuffer instanceof ArrayBuffer)) {
                    throw new Error("Invalid or missing arrayBuffer");
                }
                if (!fileName || typeof fileName !== "string") {
                    throw new Error("Invalid or missing fileName");
                }
                if (!fileType || typeof fileType !== "string" || !fileType.startsWith("image/")) {
                    throw new Error("Invalid or missing fileType");
                }
                console.log("Worker: Processing file:", fileName, "type:", fileType, "size:", arrayBuffer.byteLength);
                const file = new File([arrayBuffer], fileName, { type: fileType });
                const dataURL = await removeBg(file);
                console.log("Worker: Background removal complete, dataURL length:", dataURL.length);
                self.postMessage({ type: "result", data: dataURL });
            } catch (err) {
                console.error("Worker: Error during background removal:", err);
                self.postMessage({ type: "error", error: err.message || "Failed to remove background" });
            }
        } else {
            console.error("Worker: Unknown message type:", type);
            self.postMessage({ type: "error", error: "Unknown message type: " + type });
        }
    };

    async function preprocessImage(file) {
        console.log("Worker: Preprocessing image");
        try {
            if (!(file instanceof File)) {
                throw new Error("Invalid file object");
            }

            const bitmap = await createImageBitmap(file);
            const targetW = 1024;
            const targetH = 1024;
            const originalSize = {
                width: bitmap.width,
                height: bitmap.height
            };
            console.log("Worker: Image loaded, original size:", originalSize);

            if (typeof OffscreenCanvas === "undefined") {
                throw new Error("OffscreenCanvas is not supported in this browser");
            }

            const canvas = new OffscreenCanvas(targetW, targetH);
            const ctx = canvas.getContext("2d");
            if (!ctx) {
                throw new Error("Failed to get 2D context from OffscreenCanvas");
            }
            ctx.drawImage(bitmap, 0, 0, targetW, targetH);
            const imageData = ctx.getImageData(0, 0, targetW, targetH);
            const data = imageData.data;

            const floatData = new Float32Array(3 * targetW * targetH);
            const means = [0.485, 0.456, 0.406];
            const stds = [0.229, 0.224, 0.225];
            for (let i = 0; i < targetW * targetH; i++) {
                let r = data[i * 4 + 0] / 255.0;
                let g = data[i * 4 + 1] / 255.0;
                let b = data[i * 4 + 2] / 255.0;
                r = (r - means[0]) / stds[0];
                g = (g - means[1]) / stds[1];
                b = (b - means[2]) / stds[2];
                floatData[i] = r;
                floatData[i + targetW * targetH] = g;
                floatData[i + 2 * targetW * targetH] = b;
            }
            const inputTensor = new ort.Tensor("float32", floatData, [1, 3, targetH, targetW]);
            console.log("Worker: Image preprocessed, tensor created");

            return {
                tensor: inputTensor,
                originalImage: bitmap,
                originalSize: originalSize
            };
        } catch (err) {
            console.error("Worker: Error in preprocessImage:", err);
            throw err;
        }
    }

    function createBinaryMask(maskTensor, originalSize) {
        console.log("Worker: Creating binary mask");
        try {
            if (!maskTensor || !maskTensor.data) {
                throw new Error("Invalid mask tensor");
            }
            const maskData = maskTensor.data;
            const [n, c, h, w] = maskTensor.dims;

            const maskCanvas = new OffscreenCanvas(w, h);
            const ctx = maskCanvas.getContext("2d");
            if (!ctx) {
                throw new Error("Failed to get 2D context from OffscreenCanvas");
            }
            const maskImageData = ctx.createImageData(w, h);

            for (let i = 0; i < w * h; i++) {
                const val = maskData[i] > 0.5 ? 1 : 0;
                const idx = i * 4;
                maskImageData.data[idx + 0] = val * 255;
                maskImageData.data[idx + 1] = val * 255;
                maskImageData.data[idx + 2] = val * 255;
                maskImageData.data[idx + 3] = 255;
            }
            ctx.putImageData(maskImageData, 0, 0);

            const resizedMaskCanvas = new OffscreenCanvas(originalSize.width, originalSize.height);
            const ctxResized = resizedMaskCanvas.getContext("2d");
            if (!ctxResized) {
                throw new Error("Failed to get 2D context from OffscreenCanvas");
            }
            ctxResized.drawImage(maskCanvas, 0, 0, originalSize.width, originalSize.height);

            const binaryMaskData = ctxResized.getImageData(0, 0, originalSize.width, originalSize.height).data;
            console.log("Worker: Binary mask created, size:", originalSize);
            return binaryMaskData;
        } catch (err) {
            console.error("Worker: Error in createBinaryMask:", err);
            throw err;
        }
    }

    function deductMask(originalImage, binaryMaskData) {
        console.log("Worker: Deducting mask");
        try {
            if (!originalImage || !binaryMaskData) {
                throw new Error("Invalid originalImage or binaryMaskData");
            }
            const canvas = new OffscreenCanvas(originalImage.width, originalImage.height);
            const ctx = canvas.getContext("2d");
            if (!ctx) {
                throw new Error("Failed to get 2D context from OffscreenCanvas");
            }
            ctx.drawImage(originalImage, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const maskValue = binaryMaskData[i] / 255.0;
                data[i + 0] = data[i + 0] * maskValue; // Red
                data[i + 1] = data[i + 1] * maskValue; // Green
                data[i + 2] = data[i + 2] * maskValue; // Blue
                data[i + 3] = binaryMaskData[i];       // Alpha (255 for foreground, 0 for background)
            }
            ctx.putImageData(imageData, 0, 0);
            return canvas.convertToBlob({ type: "image/png" }).then(blob => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        const dataURL = reader.result;
                        console.log("Worker: Mask deducted, dataURL created, length:", dataURL.length);
                        resolve(dataURL);
                    };
                    reader.onerror = err => {
                        console.error("Worker: Failed to read blob as data URL:", err);
                        reject(err);
                    };
                    reader.readAsDataURL(blob);
                });
            }).catch(err => {
                console.error("Worker: Failed to convert canvas to blob:", err);
                throw err;
            });
        } catch (err) {
            console.error("Worker: Error in deductMask:", err);
            throw err;
        }
    }

    async function removeBg(file) {
        console.log("Worker: Starting background removal");
        try {
            const { tensor, originalImage, originalSize } = await preprocessImage(file);
            const feeds = {};
            feeds[session.inputNames[0]] = tensor;
            console.log("Worker: Running model inference");
            const results = await session.run(feeds);
            const output = results[session.outputNames[0]];
            console.log("Worker: Model inference complete");
            const binaryMaskData = createBinaryMask(output, originalSize);
            const dataURL = await deductMask(originalImage, binaryMaskData);
            console.log("Worker: Background removal complete");
            return dataURL;
        } catch (err) {
            console.error("Worker: Error in removeBg:", err);
            throw err;
        }
    }
  `;
  const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
  const workerUrl = URL.createObjectURL(workerBlob);
  worker = new Worker(workerUrl);
  initWorker();
</script>