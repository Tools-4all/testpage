{% extends 'base_template.html' %}
{% block content %}
{% load static %}


<head>
  <title>Online Voice Recorder</title>
  <link rel="stylesheet" href="{% static 'css/voiceRecorder.css' %}?v=2" />
  <link rel="stylesheet" href="{% static 'css/page_info.css' %}" />
  <link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.0/lame.min.js"></script>

</head>

<body>

  <div class="titleDiv">
    <h1 class="functionTitle">Online Voice Recorder</h1>
    <div class="btn-info" id="infoBtn">
      <svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" fill="currentColor" class="bi bi-info-circle"
        viewBox="0 0 16 16">
        <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14m0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16" />
        <path
          d="m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0" />
      </svg>
    </div>
  </div>

  <div class="info-div" id="infoDiv">
    <h2>User Guide</h2>
    <p>Our Voice Recorder tool allows you to capture high-quality audio effortlessly. Perfect for recording meetings,
      lectures, podcasts, or personal notes, this tool is intuitive and efficient.</p>

    <h3>How to Use:</h3>
    <ol>
      <li><strong>Start Recording</strong> – Click the "Record" button to begin capturing your voice immediately.</li>
      <li><strong>Pause and Resume</strong> – Use the pause button to temporarily halt the recording, then resume when
        you're ready.</li>
      <li><strong>Stop Recording</strong> – Click the "Stop" button to end your recording session.</li>
      <li><strong>Review and Save</strong> – Listen to your recording using the playback feature and download your
        audio
        in MP3, WAV, or WebM format if you're satisfied.</li>
    </ol>

    <h3>Features:</h3>
    <p>This tool offers an intuitive interface with a live timer, pause/resume controls, and instant playback preview.
      Enjoy clear, high-quality audio recording without any installation or registration.</p>
  </div>


  <div id="chooseMicModal">
    <div class="modal-content">
      <h2>Choose Microphone</h2>
      <select id="micSelect"></select>
      <div class="button-container">
        <button id="cancelButton">Cancel</button>
        <button id="saveButton">Save</button>
      </div>
    </div>
  </div>

  <div class="voice_recorder_container">
    <div id="microphone">
      <i class="fa-solid fa-microphone"></i>
    </div>

    <div class="controls">
      <button id="recordButton">
        <span id="recordText">Record</span> <img src="{% static 'site_images/record.png' %}" alt="Start Recorder">
      </button>
      <button id="pauseRecordButton" class="pause" disabled><i class="fa-solid fa-pause"></i></button>
      <button id="stopButton" disabled>
        <i class="fa-solid fa-stop"></i>
      </button>
      <button id="reRecordButton" disabled>Re‑record</button>
      <button id="playPauseButton" disabled>
        <i class="fa-solid fa-play"></i>
      </button>
    </div>
    <canvas id="waveformCanvas"></canvas>
    <div id="timestamp">
      <span id="blinkingDot" class="blinking-dot"></span>
      <span id="pauseIcon"><i class="fa-solid fa-pause"></i></span>
      <span id="timerText">00:00</span>
    </div>
    <div class="download-section" id="downloadSection" style="display:none;">
      <div class="btn-circle-download" id="downloadButton">
        <div>
          <span style="font-size: 20px;font-weight: 500;"></span>
        </div>
        <div>
          <select id="downloadFormat">
            <option value="mp3" selected>MP3</option>
            <option value="wav">WAV</option>
            <option value="webm">WebM</option>
          </select>
        </div>
        <div style="margin-left: 22px;margin-top: 15px;z-index: 999;" onclick="">
          <svg id="arrow" wi3dth="14px" height="20px" viewBox="17 14 14 20" style="margin-left: 10px;">
            <path d="M24,15 L24,32"></path>
            <polyline points="30 27 24 33 18 27"></polyline>
          </svg>
          <svg id="check" width="21px" height="15px" viewBox="13 17 21 15">
            <polyline points="32.5 18.5 20 31 14.5 25.5"></polyline>
          </svg>
          <svg id="border" width="48px" height="48px" viewBox="0 0 48 48">
            <path
              d="M24,1 L24,1 L24,1 C36.7025492,1 47,11.2974508 47,24 L47,24 L47,24 C47,36.7025492 36.7025492,47 24,47 L24,47 L24,47 C11.2974508,47 1,36.7025492 1,24 L1,24 L1,24 C1,11.2974508 11.2974508,1 24,1 L24,1 Z">
            </path>
          </svg>
        </div>
      </div>
    </div>
  </div>


  <div id="page-info" class="info-section" data-aos="fade" data-aos-duration="700" style="margin-top: 100px;">
    <h2 class="info-title">Capture Crisp, Clear Audio Recordings</h2>
    <p class="info-text">
      Experience the ultimate voice recording solution designed for professionals and content creators.
      Our robust tool lets you record your voice in high fidelity with crystal-clear sound, ensuring every nuance is
      captured flawlessly.
      Whether you're producing podcasts, recording interviews, or capturing important conversations, our recorder
      delivers unmatched performance and clarity.
    </p>
    <h3 class="info-subtitle">Why Choose Our Voice Recorder?</h3>
    <ul class="info-list">
      <li class="info-list-item">Record with high-fidelity audio for professional sound quality.</li>
      <li class="info-list-item">Intuitive, user-friendly interface for effortless voice capture.</li>
      <li class="info-list-item">Powerful controls to pause, resume, and stop your recordings seamlessly.</li>
      <li class="info-list-item">Optimized for speed, efficiency, and clarity—completely free to use.</li>
    </ul>
    <p class="info-text">
      Unlock your creative potential and capture every word with razor-sharp audio clarity.
      Start recording now and let your voice shine in every project!
    </p>
  </div>

  <div id="page-blog" class="blog-content" data-aos="fade" data-aos-duration="700">
    <h2>Master Voice Recording: Capture Every Word with Clarity</h2>
    <p>
      <span class="black-strong">Voice recording</span> is a game-changing tool for digital creators, educators, and
      professionals.
      It captures every nuance of your voice with exceptional clarity, making your podcasts, interviews, and audio
      memos
      more engaging and professional.
    </p>

    <h3>Why Is Voice Recording Essential?</h3>
    <p>
      In today's digital age, voice recording is vital for:
    </p>
    <ul>
      <li><strong>Creating professional podcasts:</strong> Produce clear, engaging audio content with ease.</li>
      <li><strong>Documenting important conversations:</strong> Preserve every word of your meetings and interviews.
      </li>
      <li><strong>Recording interviews:</strong> Capture the nuances of every discussion with superior sound quality.
      </li>
      <li><strong>Enhancing training sessions:</strong> Deliver detailed audio instructions complemented by
        crystal-clear commentary.</li>
    </ul>

    <h3>Key Features of Our Voice Recorder</h3>
    <p>
      Our tool is packed with advanced features designed to elevate your recording experience:
    </p>
    <ul>
      <li><strong>High-Quality Audio Recording:</strong> Capture your voice with exceptional clarity.</li>
      <li><strong>User-Friendly Controls:</strong> Easily pause, resume, and stop recordings using dynamic on-screen
        controls.</li>
      <li><strong>Instant Playback:</strong> Preview your recordings immediately to ensure perfection.</li>
      <li><strong>Fast & Free:</strong> Enjoy a lightning-fast, no-cost recording solution for all your needs.</li>
    </ul>

    <h3>How to Use the Voice Recorder?</h3>
    <p>
      Getting started is a breeze:
    </p>
    <ol>
      <li><strong>Start Recording:</strong> Click "Record" to begin capturing your voice immediately.</li>
      <li><strong>Pause and Resume:</strong> Use intuitive controls to pause or resume your recording as needed.</li>
      <li><strong>Stop Recording:</strong> Click "Stop" to end your session when you're finished.</li>
      <li><strong>Review and Save:</strong> Instantly preview your audio and download it for editing or sharing.</li>
    </ol>
    <p class="info-text" style="color: #FF0000; font-weight: bold;">
      Important: This advanced Voice Recorder tool is optimized for desktop use and may not be fully supported on all
      devices.
      For the best performance, please use a modern desktop browser.
    </p>

    <h3>Who Can Benefit from Our Voice Recorder?</h3>
    <p>
      Our cutting-edge tool is perfect for:
    </p>
    <ul>
      <li><strong>Content Creators:</strong> Produce captivating podcasts, interviews, and audio reviews.</li>
      <li><strong>Educators:</strong> Record lectures and instructional sessions with clear audio commentary.</li>
      <li><strong>Professionals:</strong> Capture meetings and interviews with precision and clarity.</li>
      <li><strong>Podcasters:</strong> Create and share high-quality audio content that engages your audience.</li>
    </ul>

    <h3>Start Recording Your Voice Now</h3>
    <p>
      Whether you're <strong>producing podcasts</strong>, <strong>recording interviews</strong>, or <strong>capturing
        important conversations</strong>,
      our state-of-the-art voice recorder provides the clarity and performance you need.
      Try it today and experience the next level of audio recording!
    </p>
    <p style="text-align: center; margin-top: 20px;">
      <a href="{% url 'tools_menu' %}">
        Explore More Tools
      </a>
    </p>
  </div>

  <section class="faq-section" data-aos="fade" data-aos-duration="700">
    <h2 class="faq-title">Frequently Asked Questions (FAQ)</h2>
    <div class="faq">
      <h3 class="faq-question" onclick="toggleAnswer(this)">What is the Voice Recorder tool?</h3>
      <div class="faq-answer">
        <p>Our Voice Recorder allows you to capture high-quality audio of your voice and ambient sounds.
          It’s perfect for creating podcasts, recording interviews, and capturing meetings.</p>
      </div>
    </div>
    <div class="faq">
      <h3 class="faq-question" onclick="toggleAnswer(this)">Can I record audio clearly with the Voice Recorder?</h3>
      <div class="faq-answer">
        <p>Yes, our tool integrates advanced audio recording capabilities to capture your voice and surrounding sounds
          with exceptional quality.</p>
      </div>
    </div>
    <div class="faq">
      <h3 class="faq-question" onclick="toggleAnswer(this)">Is this tool free to use?</h3>
      <div class="faq-answer">
        <p>Absolutely! Our powerful Voice Recorder is completely free, offering premium recording features without any
          hidden costs.</p>
      </div>
    </div>
    <div class="faq">
      <h3 class="faq-question" onclick="toggleAnswer(this)">What can I record with this tool?</h3>
      <div class="faq-answer">
        <p>You can record your voice, interviews, lectures, or any ambient audio input—ensuring crystal-clear
          recordings
          every time.</p>
      </div>
    </div>
    <div class="faq">
      <h3 class="faq-question" onclick="toggleAnswer(this)">Can I preview my recording before saving?</h3>
      <div class="faq-answer">
        <p>Yes, immediately after stopping the recording, you can preview your audio to ensure it meets your standards
          before downloading.</p>
      </div>
    </div>
  </section>

  <div id="tooltip"></div>

  <script src=" https://unpkg.com/aos@next/dist/aos.js"></script>
  <script>AOS.init();</script>

  <script>
let mediaRecorder, recordedChunks = [];
let audioBlob, audioUrl, audio;
let stream;
let recordingAnimationId, playbackAnimationId;
let recordingAmplitudes = [];
const sampleScale = 2;
let totalDuration = 0;
let recordStartTime = 0;
let isPlaying = false;
let pauseStartTime = 0;
let totalPausedTime = 0;

const waveformCanvas = document.getElementById('waveformCanvas');
const canvasCtx = waveformCanvas.getContext('2d');
const recordButton = document.getElementById('recordButton');
const stopButton = document.getElementById('stopButton');
const reRecordButton = document.getElementById('reRecordButton');
const playPauseButton = document.getElementById('playPauseButton');
const downloadButton = document.getElementById('downloadButton');
const downloadSection = document.getElementById('downloadSection');
const downloadFormatSelect = document.getElementById('downloadFormat');
const timestampDisplay = document.getElementById('timestamp');
const tooltip = document.getElementById('tooltip');
const pauseRecordButton = document.getElementById('pauseRecordButton');

async function populateMicrophones() {
  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const audioDevices = devices.filter(device => device.kind === 'audioinput');
    const micSelect = document.getElementById('micSelect');
    micSelect.innerHTML = '';

    audioDevices.forEach((device, index) => {
      const option = document.createElement('option');
      option.value = device.deviceId;
      option.textContent = device.label || `Microphone ${index + 1}`;
      micSelect.appendChild(option);
    });
  } catch (err) {
    console.error('Error enumerating devices:', err);
  }
}

document.getElementById('microphone').addEventListener('click', () => {
  document.getElementById('chooseMicModal').style.display = 'flex';
  populateMicrophones();
});

document.getElementById('cancelButton').addEventListener('click', () => {
  document.getElementById('chooseMicModal').style.display = 'none';
});

document.getElementById('saveButton').addEventListener('click', async () => {
  const selectedDeviceId = document.getElementById('micSelect').value;
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: { deviceId: selectedDeviceId ? { exact: selectedDeviceId } : undefined }
    });
    console.log('Microphone stream started:', stream);
  } catch (err) {
    console.error('Error accessing microphone:', err);
  }
  document.getElementById('chooseMicModal').style.display = 'none';
});

populateMicrophones();

document.getElementById('chooseMicModal').addEventListener('click', (event) => {
  if (event.target.id === 'chooseMicModal') {
    document.getElementById('chooseMicModal').style.display = 'none';
  }
});

// Set MIME type with a preference for an iOS-compatible format.
let audioContext, analyser;
let mimeType = '';
if (MediaRecorder.isTypeSupported('audio/mp4')) {
  mimeType = 'audio/mp4';
} else if (MediaRecorder.isTypeSupported('audio/webm')) {
  mimeType = 'audio/webm';
} else if (MediaRecorder.isTypeSupported('audio/ogg; codecs=opus')) {
  mimeType = 'audio/ogg; codecs=opus';
} else {
  alert("No supported audio format available for recording.");
}

function resizeCanvas() {
  waveformCanvas.width = waveformCanvas.clientWidth;
  waveformCanvas.height = waveformCanvas.clientHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function recordingAnimationFrame() {
  let bufferLength = analyser.frequencyBinCount;
  let dataArray = new Uint8Array(bufferLength);
  analyser.getByteTimeDomainData(dataArray);
  let sum = 0;
  for (let i = 0; i < bufferLength; i++) {
    sum += Math.abs(dataArray[i] - 128);
  }
  let amplitude = sum / (bufferLength * 128);
  recordingAmplitudes.push(amplitude);

  drawRecordingCanvas();
  updateRecordingTimestamp();

  recordingAnimationId = requestAnimationFrame(recordingAnimationFrame);
}

function drawRecordingCanvas() {
  canvasCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
  let virtualWidth = recordingAmplitudes.length * sampleScale;
  let startSample = virtualWidth > waveformCanvas.width
    ? Math.floor((virtualWidth - waveformCanvas.width) / sampleScale)
    : 0;

  canvasCtx.strokeStyle = "#ff416c";
  canvasCtx.lineWidth = 1;
  for (let i = startSample; i < recordingAmplitudes.length; i++) {
    let x = (i - startSample) * sampleScale;
    let amp = recordingAmplitudes[i];
    let lineHeight = amp * waveformCanvas.height;
    let yStart = (waveformCanvas.height - lineHeight) / 2;
    let yEnd = yStart + lineHeight;
    canvasCtx.beginPath();
    canvasCtx.moveTo(x, yStart);
    canvasCtx.lineTo(x, yEnd);
    canvasCtx.stroke();
  }
  let playheadX = Math.min(
    (recordingAmplitudes.length - startSample) * sampleScale,
    waveformCanvas.width
  );
  canvasCtx.strokeStyle = "#ffffff";
  canvasCtx.beginPath();
  canvasCtx.moveTo(playheadX, 0);
  canvasCtx.lineTo(playheadX, waveformCanvas.height);
  canvasCtx.stroke();
}

function updateRecordingTimestamp() {
  const elapsed = (Date.now() - recordStartTime - totalPausedTime) / 1000;
  document.getElementById('timerText').textContent = formatTime(elapsed);
}

function drawPlaybackCanvas(progress) {
  canvasCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
  const n = recordingAmplitudes.length;
  canvasCtx.strokeStyle = "#ff416c";
  canvasCtx.lineWidth = 1;

  for (let x = 0; x < waveformCanvas.width; x++) {
    let sampleIndex = Math.floor((x / waveformCanvas.width) * n);
    let amp = recordingAmplitudes[sampleIndex] || 0;
    let lineHeight = amp * waveformCanvas.height;
    let yStart = (waveformCanvas.height - lineHeight) / 2;
    let yEnd = yStart + lineHeight;
    canvasCtx.beginPath();
    canvasCtx.moveTo(x, yStart);
    canvasCtx.lineTo(x, yEnd);
    canvasCtx.stroke();
  }
  let playheadX = progress * waveformCanvas.width;
  canvasCtx.fillStyle = "rgba(0,210,255,0.3)";
  canvasCtx.fillRect(0, 0, playheadX, waveformCanvas.height);

  canvasCtx.strokeStyle = "#ffffff";
  canvasCtx.beginPath();
  canvasCtx.moveTo(playheadX, 0);
  canvasCtx.lineTo(playheadX, waveformCanvas.height);
  canvasCtx.stroke();
}

function updatePlayback() {
  if (!audio || totalDuration <= 0) return;

  if (audio.currentTime >= totalDuration - 0.01) {
    audio.pause();
    audio.currentTime = 0;
    isPlaying = false;
    playPauseButton.innerHTML = '<i class="fa-solid fa-play"></i>';
    drawPlaybackCanvas(0);
    updateTimestamp(0, totalDuration);
    return;
  }

  let progress = audio.currentTime / totalDuration;
  drawPlaybackCanvas(progress);
  updateTimestamp(audio.currentTime, totalDuration);

  if (!audio.paused && !audio.ended) {
    playbackAnimationId = requestAnimationFrame(updatePlayback);
  }
}

function updateTimestamp(current, total) {
  document.getElementById('timerText').textContent = formatTime(current) + " / " + formatTime(total);
}

function formatTime(seconds) {
  const m = Math.floor(seconds / 60);
  const s = Math.floor(seconds % 60);
  return (m < 10 ? "0" + m : m) + ":" + (s < 10 ? "0" + s : s);
}

recordButton.addEventListener("click", async () => {
  try {
    stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  } catch (err) {
    alert("Error accessing microphone: " + err);
    return;
  }
  audioContext = new (window.AudioContext || window.webkitAudioContext)();
  // Ensure the AudioContext is resumed (required on iOS)
  if (audioContext.state === 'suspended') {
    await audioContext.resume();
  }
  const source = audioContext.createMediaStreamSource(stream);
  analyser = audioContext.createAnalyser();
  analyser.fftSize = 2048;
  source.connect(analyser);

  recordingAmplitudes = [];
  recordStartTime = Date.now();
  totalPausedTime = 0;
  canvasCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
  recordedChunks = [];

  try {
    mediaRecorder = new MediaRecorder(stream, { mimeType });
  } catch (e) {
    alert("MediaRecorder not supported: " + e);
    return;
  }

  mediaRecorder.ondataavailable = (event) => {
    if (event.data.size > 0) recordedChunks.push(event.data);
  };

  mediaRecorder.onstop = () => {
    cancelAnimationFrame(recordingAnimationId);
    stream.getTracks().forEach((track) => track.stop());

    audioBlob = new Blob(recordedChunks, { type: mimeType || "audio/webm" });
    audioUrl = URL.createObjectURL(audioBlob);

    audio = new Audio(audioUrl);
    audio.onloadedmetadata = () => {
      if (isFinite(audio.duration) && audio.duration > 0) {
        totalDuration = audio.duration;
      }
      updateTimestamp(audio.currentTime, totalDuration);
    };

    audio.onended = () => {
      audio.currentTime = 0;
      isPlaying = false;
      playPauseButton.innerHTML = '<i class="fa-solid fa-play"></i>';
      drawPlaybackCanvas(0);
      updateTimestamp(0, totalDuration);
    };

    playPauseButton.disabled = false;
    reRecordButton.disabled = false;
    downloadSection.style.display = "block";

    const reader = new FileReader();
    reader.onload = (e) => {
      const arrayBuffer = e.target.result;
      const tempCtx = new (window.AudioContext || window.webkitAudioContext)();
      tempCtx.decodeAudioData(arrayBuffer, (audioBuffer) => {
        totalDuration = audioBuffer.duration;
        updateTimestamp(0, totalDuration);
        drawPlaybackCanvas(0);
      });
    };
    reader.readAsArrayBuffer(audioBlob);
  };

  mediaRecorder.start();
  recordingAnimationId = requestAnimationFrame(recordingAnimationFrame);

  document.getElementById('microphone').style.display = 'none';
  document.getElementById('blinkingDot').style.display = 'inline-block';
  recordButton.disabled = true;
  pauseRecordButton.disabled = false;
  stopButton.disabled = false;
  reRecordButton.disabled = true;
  playPauseButton.disabled = true;
});

pauseRecordButton.addEventListener("click", () => {
  if (!mediaRecorder) return;

  if (mediaRecorder.state === "recording") {
    mediaRecorder.pause();
    pauseStartTime = Date.now();
    cancelAnimationFrame(recordingAnimationId);
    pauseRecordButton.style.fontSize = '20px';
    pauseRecordButton.textContent = "REC";
    document.getElementById('blinkingDot').style.display = 'none';
    document.getElementById('pauseIcon').style.display = 'inline-block';
  } else if (mediaRecorder.state === "paused") {
    mediaRecorder.resume();
    totalPausedTime += Date.now() - pauseStartTime;
    recordingAnimationId = requestAnimationFrame(recordingAnimationFrame);
    pauseRecordButton.style.fontSize = '24px';
    pauseRecordButton.innerHTML = '<i class="fa-solid fa-pause"></i>';
    document.getElementById('blinkingDot').style.display = 'inline-block';
    document.getElementById('pauseIcon').style.display = 'none';
  }
});

stopButton.addEventListener("click", () => {
  if (mediaRecorder && mediaRecorder.state !== "inactive") {
    mediaRecorder.stop();
  }
  document.getElementById('blinkingDot').style.display = 'none';
  document.getElementById('pauseIcon').style.display = 'none';

  pauseRecordButton.disabled = true;
  pauseRecordButton.innerHTML = '<i class="fa-solid fa-pause"></i>';

  waveformCanvas.style.cursor = "pointer";

  stopButton.disabled = true;
});

reRecordButton.addEventListener("click", () => {
  cancelAnimationFrame(recordingAnimationId);
  cancelAnimationFrame(playbackAnimationId);
  canvasCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);

  waveformCanvas.style.cursor = "default";

  document.getElementById('microphone').style.display = 'inline-block';
  recordButton.disabled = false;
  stopButton.disabled = true;
  reRecordButton.disabled = true;
  playPauseButton.disabled = true;
  downloadSection.style.display = "none";
  document.getElementById('timerText').textContent = "00:00";

  audioBlob = null;
  audioUrl = null;
  recordingAmplitudes = [];
  totalDuration = 0;
  audio = null;
});

playPauseButton.addEventListener("click", () => {
  try {
    if (audio && audio.paused) {
      audio.play().catch(err => console.error("Playback error:", err));
      isPlaying = true;
      playPauseButton.innerHTML = '<i class="fa-solid fa-pause"></i>';
      playPauseButton.style.paddingLeft = "3px";
      requestAnimationFrame(updatePlayback);
    } else if (audio) {
      audio.pause();
      isPlaying = false;
      playPauseButton.innerHTML = '<i class="fa-solid fa-play"></i>';
      playPauseButton.style.paddingLeft = "9px";
    } else {
      // Fallback: if no audio exists yet.
      // Optionally add logic to handle this case.
    }
  }
  catch (e) {
    alert("Error playing audio: " + e);
  }
});

let isSeeking = false;
function seekAudio(e) {
  if (!audio || totalDuration <= 0) return;
  const rect = waveformCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const newTime = (x / waveformCanvas.width) * totalDuration;
  audio.currentTime = newTime;
  drawPlaybackCanvas(newTime / totalDuration);
  updateTimestamp(newTime, totalDuration);
}
waveformCanvas.addEventListener("mousedown", (e) => {
  isSeeking = true;
  seekAudio(e);
});
window.addEventListener("mousemove", (e) => {
  if (isSeeking) {
    seekAudio(e);
  }
});
window.addEventListener("mouseup", () => {
  isSeeking = false;
});
waveformCanvas.addEventListener("mousemove", (e) => {
  if (totalDuration <= 0) return;
  const rect = waveformCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const timeAtCursor = (x / waveformCanvas.width) * totalDuration;
  tooltip.textContent = formatTime(timeAtCursor);
  tooltip.style.left = (e.clientX + 10) + "px";
  tooltip.style.top = (e.clientY + 10) + "px";
  tooltip.style.display = "block";
});
waveformCanvas.addEventListener("mouseleave", () => {
  tooltip.style.display = "none";
});

function convertBlobToWav(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = function () {
      const arrayBuffer = reader.result;
      const tempCtx = new (window.AudioContext || window.webkitAudioContext)();
      tempCtx.decodeAudioData(arrayBuffer, (audioBuffer) => {
        const wavBuffer = audioBufferToWav(audioBuffer);
        const wavBlob = new Blob([wavBuffer], { type: "audio/wav" });
        resolve(wavBlob);
      }, reject);
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(blob);
  });
}
function audioBufferToWav(buffer) {
  const numChannels = buffer.numberOfChannels;
  const sampleRate = buffer.sampleRate;
  const bitDepth = 16;
  let samples;
  if (numChannels === 2) {
    const left = buffer.getChannelData(0);
    const right = buffer.getChannelData(1);
    samples = interleave(left, right);
  } else {
    samples = buffer.getChannelData(0);
  }
  return encodeWAV(samples, numChannels, sampleRate, bitDepth);
}
function interleave(leftChannel, rightChannel) {
  const length = leftChannel.length + rightChannel.length;
  const result = new Float32Array(length);
  let inputIndex = 0;
  for (let index = 0; index < length;) {
    result[index++] = leftChannel[inputIndex];
    result[index++] = rightChannel[inputIndex];
    inputIndex++;
  }
  return result;
}
function encodeWAV(samples, numChannels, sampleRate, bitDepth) {
  const bytesPerSample = bitDepth / 8;
  const blockAlign = numChannels * bytesPerSample;
  const buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
  const view = new DataView(buffer);
  writeString(view, 0, "RIFF");
  view.setUint32(4, 36 + samples.length * bytesPerSample, true);
  writeString(view, 8, "WAVE");
  writeString(view, 12, "fmt ");
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * blockAlign, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, bitDepth, true);
  writeString(view, 36, "data");
  view.setUint32(40, samples.length * bytesPerSample, true);
  if (bitDepth === 16) {
    floatTo16BitPCM(view, 44, samples);
  } else {
    for (let i = 0; i < samples.length; i++) {
      view.setFloat32(44 + i * 4, samples[i], true);
    }
  }
  return view;
}
function floatTo16BitPCM(output, offset, input) {
  for (let i = 0; i < input.length; i++, offset += 2) {
    const s = Math.max(-1, Math.min(1, input[i]));
    output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
  }
}
function writeString(view, offset, string) {
  for (let i = 0; i < string.length; i++) {
    view.setUint8(offset + i, string.charCodeAt(i));
  }
}
function convertBlobToMp3(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = function () {
      const arrayBuffer = reader.result;
      const tempCtx = new (window.AudioContext || window.webkitAudioContext)();
      tempCtx.decodeAudioData(arrayBuffer, (audioBuffer) => {
        const channelData = audioBuffer.getChannelData(0);
        const sampleRate = audioBuffer.sampleRate;
        function convertFloat32ToInt16(buffer) {
          let l = buffer.length;
          let buf = new Int16Array(l);
          for (let i = 0; i < l; i++) {
            let s = Math.max(-1, Math.min(1, buffer[i]));
            buf[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
          }
          return buf;
        }
        const int16Samples = convertFloat32ToInt16(channelData);
        const mp3encoder = new lamejs.Mp3Encoder(1, sampleRate, 128);
        const sampleBlockSize = 1152;
        let mp3Data = [];
        for (let i = 0; i < int16Samples.length; i += sampleBlockSize) {
          const sampleChunk = int16Samples.subarray(i, i + sampleBlockSize);
          const mp3buf = mp3encoder.encodeBuffer(sampleChunk);
          if (mp3buf.length > 0) {
            mp3Data.push(new Int8Array(mp3buf));
          }
        }
        const d = mp3encoder.flush();
        if (d.length > 0) {
          mp3Data.push(new Int8Array(d));
        }
        const mp3Blob = new Blob(mp3Data, { type: "audio/mp3" });
        resolve(mp3Blob);
      }, reject);
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(blob);
  });
}

downloadButton.addEventListener("click", async () => {
  if (!audioBlob) return;
  const selectedFormat = downloadFormatSelect.value;
  let blobToDownload = audioBlob;
  let filename = "recording";
  if (selectedFormat === "mp3") {
    downloadButton.disabled = true;
    try {
      blobToDownload = await convertBlobToMp3(audioBlob);
      filename += ".mp3";
    } catch (e) {
      alert("Error converting to MP3: " + e);
      downloadButton.disabled = false;
      return;
    }
  } else if (selectedFormat === "wav") {
    downloadButton.disabled = true;
    try {
      blobToDownload = await convertBlobToWav(audioBlob);
      filename += ".wav";
    } catch (e) {
      alert("Error converting to WAV: " + e);
      downloadButton.disabled = false;
      return;
    }
  } else if (selectedFormat === "webm") {
    if (audioBlob.type === "audio/webm") {
      filename += ".webm";
    } else {
      alert("WebM conversion not supported. Using original format.");
      filename += ".webm";
    }
  }
  const a = document.createElement("a");
  a.style.display = "none";
  a.href = URL.createObjectURL(blobToDownload);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  URL.revokeObjectURL(a.href);
  document.body.removeChild(a);
  downloadButton.disabled = false;
  show_anim();
});

downloadFormatSelect.addEventListener("click", function (event) {
  event.stopPropagation();
});

let resetReq = false;
function show_anim() {
  if (resetReq) {
    return;
  }
  resetReq = true;
  downloadButton.classList.add('load');

  setTimeout(function () {
    downloadButton.classList.add('done');
  }, 1000);

  setTimeout(function () {
    downloadButton.classList.remove('load', 'done');
    resetReq = false;
  }, 2500);
}

alert("Important: This advanced Voice Recorder tool is optimized for desktop use and may not be fully supported on all devices. For the best performance, please use a modern desktop browser.");

  </script>
  <script src="{% static 'js/page_info.js' %}"></script>

</body>

{% endblock %}