{% load static %}
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Multi-Tab Sandboxed JS Compiler</title>
  <link href="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.snow.css" rel="stylesheet">
  <link rel="stylesheet" data-name="vs/editor/editor.main"
    href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.52.2/min/vs/editor/editor.main.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap" rel="stylesheet" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }


    body {
      user-select: none;
      -webkit-user-drag: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    .allowSelect {
      user-select: text !important;
      -webkit-user-drag: text !important;
      -webkit-user-select: text !important;
      -moz-user-select: text !important;
      -ms-user-select: text !important;
    }

    .dontAllowSelect {
      user-select: none;
      -webkit-user-drag: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    .darkMode {
      background-color: #252526;
      color: #d4d4d4;
    }

    .lightMode {
      background-color: #f0f0f0;
      color: #131313;
    }

    #compiler {
      position: relative;
      font-family: 'Fira Code', monospace;
      display: flex;
      width: 60%;
      height: 500px;
      margin: 100px auto;
      overflow: hidden;
      transition: width 0.3s ease, height 0.3s ease, margin 0.3s ease;
    }

    .vs-logo {
      position: absolute;
      top: 0;
      left: 0;
      height: 40px;
      width: 40px;
      z-index: 1010;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .vs-logo img {
      height: 25px;
      width: 25px;
      object-fit: contain;
      border-radius: 4px;
      margin-bottom: 8px;
      user-select: none;
      -webkit-user-drag: none;
    }

    .vs-navbar {
      font-family: 'Fira Code', monospace;
      background-color: transparent;
      font-size: 14px;
      display: flex;
      padding: 5px 10px;
      padding-right: 5px;
      border-bottom: 1px solid;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      z-index: 1000;
      padding-left: 40px;
      height: 30px;
    }

    .vs-navbar-item {
      margin-right: 10px;
      margin-top: 1px;
      position: relative;
      cursor: pointer;
      padding: 5px;
      padding-top: 1px;
      font-size: 12px;
      border-radius: 5px;
    }

    .vs-navbar-item:hover {
      background-color: #9492923b;
    }

    .vs-navbar-dropdown {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      border: 1px solid #252526;
      border-radius: 4px;
      overflow: hidden;
      z-index: 1000;
      min-width: 120px;
    }

    .vs-navbar-dropdown.active {
      display: block;
    }

    .vs-navbar-dropdown-item {
      padding: 8px 12px;
      cursor: pointer;
      white-space: nowrap;
    }

    .vs-navbar-dropdown-item.disabled {
      pointer-events: none;
      opacity: 0.5;
    }

    #compiler:not(.darkMode) .vs-navbar-dropdown {
      background-color: #f9f9f9;
      color: #000000;
      border-color: #c0c0c0;
    }

    #compiler:not(.darkMode) .vs-navbar-dropdown.active .vs-navbar-dropdown-item:hover {
      background-color: #e0e0e0;
      color: #000000;
    }

    #compiler:not(.lightMode) .vs-navbar-dropdown {
      background-color: #3c3c3c;
      color: #ffffff;
      border-color: #4c4c4c;
    }

    #compiler:not(.lightMode) .vs-navbar-dropdown.active .vs-navbar-dropdown-item:hover {
      background-color: #444;
      color: #ffffff;
    }


    #moon,
    #sun {
      color: #636262;
      font-size: 17px;
      height: 20px;
      width: 20px;
      padding-top: 2px;
      padding-left: 4px;
      margin-left: 20px;
      cursor: pointer;
      margin-right: 20px;
      transition: color 0.2s;
    }

    #sun {
      color: #c5c5c5;
    }

    #fullScreenBtn {
      color: #c5c5c5;
      margin-top: 3px;
      margin-right: 7px;
      font-size: 13px;
      cursor: pointer;
      transition: color 0.2s;
    }

    #activityBar {
      width: 50px;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 10px;
      background-color: transparent;
      border-right: 1px solid;
      transition: width 0.3s ease;
      flex-shrink: 0;
      margin-top: 30px;
    }

    #activityBar .icon {
      padding: 12px 0;
      cursor: pointer;
      transition: background-color 0.3s, color 0.3s;
      width: 100%;
      text-align: center;
      font-size: 20px;
      position: relative;
      border-left: 3px solid transparent;
      padding-right: 3px;
    }

    #exportIcon {
      padding-left: 5px !important;
    }

    #activityBar .icon:hover:after {
      content: attr(data-label);
      position: absolute;
      left: 55px;
      top: 50%;
      transform: translateY(-50%);
      background: #333;
      padding: 5px 10px;
      font-size: 12px;
      border-radius: 3px;
      white-space: nowrap;
      z-index: 9;
    }

    #compiler:not(.darkMode) #activityBar .icon {
      color: #9b9a9a !important;
    }

    #compiler:not(.darkMode) #activityBar .icon:hover,
    #compiler:not(.darkMode) #activityBar .icon.active {
      background-color: rgb(183, 182, 182);
      color: #fffdfd !important;
    }

    #compiler:not(.darkMode) #activityBar .icon:hover:after {
      background: #acabab;
    }

    #compiler:not(.lightMode) #activityBar .icon:hover,
    #compiler:not(.lightMode) #activityBar .icon.active {
      background-color: #3c3c3c;
      color: #fff;
    }

    .sidebar-panel {
      width: 250px;
      border-right: 1px solid;
      overflow-y: auto;
      padding: 10px;
      display: none;
      flex-shrink: 0;
      margin-top: 30px;
    }

    .sidebar-panel.active {
      display: block;
    }

    #compiler:not(.darkMode) .sidebar-panel {
      background-color: #eeeeee;
      color: #545151 !important;
      border-color: #c0c0c0;
    }

    #compiler:not(.lightMode) .sidebar-panel {
      background-color: #2b2b2b;
      color: #ffffff;
      border-color: #3c3c3c;
    }

    #gitUrl {
      width: 100%;
      padding: 8px 10px;
      margin-bottom: 10px;
      background-color: #2d2d2d;
      border: 1px solid #3c3c3c;
      border-radius: 4px;
      color: #d4d4d4;
      font-family: 'Fira Code', monospace;
      font-size: 14px;
      outline: none;
      transition: border-color 0.2s;
    }

    #gitUrl:focus {
      border-color: #007acc;
    }

    #compiler:not(.darkMode) .sidebar-panel.active #gitUrl {
      background-color: #f9f9f9;
      border-color: #c0c0c0;
      color: #000000;
    }

    #compiler:not(.lightMode) .sidebar-panel.active #gitUrl {
      background-color: #3c3c3c;
      border-color: #4c4c4c;
      color: #ffffff;
    }

    #loadGitButton {
      width: 100%;
      padding: 8px 10px;
      background-color: #007acc;
      border: none;
      border-radius: 4px;
      color: white;
      font-family: 'Fira Code', monospace;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    #loadGitButton:hover {
      background-color: #005f99;
    }

    #tabSizeInput {
      width: 100%;
    }

    .vs-range {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 6px;
      background-color: #2d2d2d;
      outline: none;
      border-radius: 3px;
      cursor: pointer;
    }

    .vs-range::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      background: #007acc;
      border-radius: 50%;
      border: 2px solid #0369ae;
      box-shadow: 0 0 2px rgba(0, 0, 0, 0.2);
      cursor: pointer;
    }

    .vs-range::-moz-range-thumb {
      width: 14px;
      height: 14px;
      background: #007acc;
      border: 2px solid #0369ae;
      border-radius: 50%;
      box-shadow: 0 0 2px rgba(0, 0, 0, 0.2);
      cursor: pointer;
    }

    .vs-range::-webkit-slider-thumb:hover,
    .vs-range::-moz-range-thumb:hover {
      background: #119eff;
    }

    .vs-range::-webkit-slider-thumb:active,
    .vs-range::-moz-range-thumb:active {
      background: #0067a8;
    }

    #compiler:not(.darkMode) .sidebar-panel.active .vs-range {
      background-color: #f9f9f9;
      border: 1px solid #c0c0c0;
    }

    #compiler:not(.lightMode) .sidebar-panel.active .vs-range {
      background-color: #3c3c3c;
      border: 1px solid #4c4c4c;
    }

    .exportBtnsWrapper {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      margin-top: 30px;
    }

    #exportSelect {
      padding: 5px 5px;
      border-radius: 5px;
      width: 100%;
      max-width: 275px;
      color: #000 !important;
    }

    #exportButton {
      width: 100%;
      max-width: 275px;
      margin-left: 0px;
      margin-top: 15px;
    }

    #mainContainer {
      display: flex;
      flex-direction: column;
      flex: 1;
      margin-top: 30px;
      overflow: hidden;
    }

    #tabBar {
      border-bottom: 1px solid;
      display: flex;
      align-items: center;
      height: 30px;
      flex-shrink: 0;
      overflow: hidden;
    }

    #tabBar:hover {
      overflow-x: auto;
      overflow-y: hidden;
      transition: overflow 0.3s;
    }

    #tabBar::-webkit-scrollbar {
      height: 4px;
    }

    #tabBar::-webkit-scrollbar-thumb {
      background-color: #007acc;
      border-radius: 10px;
    }

    #tabBar::-webkit-scrollbar-track {
      background-color: transparent;
    }

    .tab {
      margin-right: 2px;
      margin-top: 3px;
      padding: 7px 10px;
      cursor: pointer;
      font-size: 13px;
      display: inline-flex;
      align-items: center;
      user-select: none;
      -webkit-user-drag: element;
    }

    .tab.active {
      border-top: 1px solid #007acc !important;
      border-bottom: 1px solid transparent;
      margin-bottom: -2px;
      border-top-left-radius: 3px;
      border-top-right-radius: 3px;
    }

    #activityBar .icon.active {
      border-left: 3px solid #007acc;
    }

    #compiler:not(.darkMode) .tab {
      background-color: #e0e0e0;
      color: #000000;
    }

    #compiler:not(.lightMode) .tab {
      background-color: #2c2c2c;
      color: #ffffff;
    }

    #compiler:not(.darkMode) .tab:hover {
      background-color: #c0c0c0;
    }

    #compiler:not(.lightMode) .tab:hover {
      background-color: #3c3c3c;
    }

    #compiler:not(.darkMode) .tab.active,
    #compiler:not(.darkMode) .tab.active:hover {
      background-color: #d0d0d0;
      border-top: 1px solid #007acc !important;
    }

    #compiler:not(.lightMode) .tab.active,
    #compiler:not(.lightMode) .tab.tab.active:hover {
      background-color: #1c1c1c;
      border-top: 1px solid #007acc !important;
    }

    .tab .tab-title {
      margin-right: 15px;
    }

    .tab .close {
      font-size: 12px;
      cursor: pointer;
      visibility: hidden
    }

    .tab:hover .close {
      visibility: visible;
    }

    .tab.active .close {
      visibility: visible;
    }

    .tab-title-edit {
      background: #555;
      border: 1px solid #666;
      color: #fff;
      width: 90px;
      font-size: 13px;
      margin-right: 8px;
      font-family: inherit;
      outline: none;
    }

    #addTabButton,
    #addTabButton_media {
      background: none;
      color: #c5c5c5;
      font-size: 17px;
      cursor: pointer;
      margin-left: 20px;
      margin-top: -1px;
      flex-shrink: 0;
      transition: color 0.2s;
    }

    #addTabButton:hover,
    #fullScreenBtn:hover,
    #sun:hover {
      color: #fff;
    }

    #compiler:not(.darkMode) #addTabButton,
    #compiler:not(.darkMode) #fullScreenBtn {
      color: #636262 !important;
    }

    #compiler:not(.darkMode) #addTabButton:hover,
    #compiler:not(.darkMode) #fullScreenBtn:hover,
    #compiler:not(.darkMode) #moon:hover {
      color: #000000 !important;
    }


    #addTabButton_media {
      font-size: 25px;
      margin-left: 0px;
      display: none;
    }

    #tabsContainer {
      position: relative;
      flex: 1;
      overflow: hidden;

    }

    .editor-and-output {
      display: none;
      flex-direction: column;
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
    }

    .editor-and-output.active {
      display: flex;
      margin-top: -1px
    }

    .editorContainer {
      flex: 1;
      position: relative;
      min-height: 0;
    }

    .monaco-editor {
      width: 100%;
      height: 100%;
      text-transform: none !important;
      user-select: none !important;
      /* -webkit-user-drag: none !important;
      -webkit-user-select: none !important;
      -moz-user-select: none !important;
      -ms-user-select: none !important; */
    }

    .monaco-editor .inputarea {
      autocapitalize: none !important;
      -webkit-autocapitalize: none !important;
    }

    .outputContainer {
      display: flex;
      flex-direction: column;
    }

    .resize {
      height: 30%;
    }

    .monaco-editor .find-widget.visible .controls {
      padding: 0px !important;
      border: none !important;
    }

    .controls {
      padding: 4px;
      cursor: ns-resize;
      user-select: none;
      border-top: 1px solid;
      border-bottom: 1px solid;
    }

    #compiler:not(.darkMode) .controls {
      background-color: #f0f0f0;
      border-color: #c0c0c0;
    }

    #compiler:not(.lightMode) .controls {
      background-color: #252526;
      border-color: #333;
    }

    #runButton {
      margin-left: auto;
      padding: 10px 12px;
      background-color: #46a22a;
      color: white;
      border: none;
      cursor: pointer;
      border-radius: 4px;
      font-size: 14px;
      display: flex;
      align-items: center;
      transition: background-color 0.3s;
    }

    #runButton:hover {
      background-color: #35851d;
    }

    #runButton i {
      margin-right: 5px;
    }

    .output {
      flex: 1;
      padding: 10px;
      overflow-y: auto;
      font-family: 'Fira Code', monospace;
      font-size: 14px;
      white-space: pre-wrap;
      overflow: hidden;
    }

    .output:hover {
      overflow: auto;
      transition: overflow 0.3s;
    }

    #compiler:not(.darkMode) .output {
      background-color: white;
    }

    #compiler:not(.lightMode) .output {
      background-color: #1e1e1e;
    }

    .output::-webkit-scrollbar {
      width: 8px;
    }

    .output::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 4px;
    }

    .output::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    .output::-webkit-scrollbar-horizontal {
      height: 8px;
    }

    #compiler:not(.darkMode) .output::-webkit-scrollbar-corner {
      background: #f0f0f0;
    }

    #compiler:not(.lightMode) .output::-webkit-scrollbar-corner {
      background: #252526;
    }

    .outputContent {
      margin-top: 2px;
      display: flex;
      flex-grow: 1;
      flex-shrink: 0;
    }

    .prompt-line {
      display: flex;
      align-items: center;
      font-size: 14px;
      margin-left: 4px;
    }

    .prompt-line span {
      margin-right: 5px;
      white-space: pre;
    }

    .promptInput {
      flex: 1;
      padding: 0;
      margin: 0;
      border: none;
      outline: none;
      background: transparent;
      font-family: 'Fira Code', monospace;
      font-size: 14px;
      caret-color: currentColor;
      margin-left: 10px;
      padding-left: 5px;
      padding-right: 5px;
      border-radius: 4px;
    }

    #compiler:not(.darkMode) .promptInput {
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    #compiler:not(.lightMode) .promptInput {
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #d4d4d4;
    }

    #statusBar {
      height: 24px;
      border-top: 1px solid;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 10px;
      font-size: 12px;
      flex-shrink: 0;
    }

    .status-item {
      margin-right: 10px;
    }

    .tab-drop-left {
      box-shadow: inset 4px 0 0 0 #007acc;
    }

    .tab-drop-right {
      box-shadow: inset -4px 0 0 0 #007acc;
    }

    .vs-button {
      background-color: #0e639c;
      color: #ffffff;
      border: none;
      padding: 6px 12px;
      margin-left: 10px;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
    }

    .vs-button:hover {
      background-color: #1177bb;
    }

    .console-table {
      border-collapse: collapse;
      font-size: 14px;
      margin-top: 4px;
      width: auto;
      width: 100%;
      max-width: 1200px;
      line-break: anywhere;
    }

    .console-table thead {
      font-weight: bold;
    }

    .console-table th,
    .console-table td {
      border: 1px solid #333;
      padding: 4px 8px;
      vertical-align: top;
    }

    #compiler:not(.lightMode) .console-table thead {
      background-color: #3c3c3c;
      color: #ffffff;
    }

    #compiler:not(.lightMode) .console-table td,
    #compiler:not(.lightMode) .console-table th {
      color: #d4d4d4;
    }


    #compiler:not(.darkMode) .console-table thead {
      background-color: #dddddd;
      color: #000000;
    }

    #compiler:not(.darkMode) .console-table td,
    #compiler:not(.darkMode) .console-table th {
      color: #333333;
    }

    #compiler:not(.lightMode) .console-table thead .console-table-header:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }

    #compiler:not(.darkMode) .console-table thead .console-table-header:hover {
      background-color: rgba(0, 0, 0, 0.1);
    }

    #compiler:not(.lightMode) .console-table tbody .console-table-row:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }

    #compiler:not(.darkMode) .console-table tbody .console-table-row:hover {
      background-color: rgba(0, 0, 0, 0.1);
    }

    #compiler:not(.darkMode) .prompt-line {
      color: #000
    }

    #compiler:not(.lightMode) .prompt-line {
      color: #ffffff
    }


    #undoBtn,
    #redoBtn {
      margin-top: 3px;
      font-size: 11px;
    }

    #undoBtn {
      margin-right: 10px;
    }


    #compiler:not(.darkMode) .log {
      color: #343434;
    }

    #compiler:not(.darkMode) .error {
      color: #cc0000;
    }

    #compiler:not(.darkMode) .warn {
      color: #cc9a00;
    }

    #compiler:not(.darkMode) .info {
      color: #0066cc;
    }

    #compiler:not(.darkMode) .prompt {
      color: #008000;
    }


    #compiler:not(.lightMode) .log {
      color: #BBBBBB;
    }

    #compiler:not(.lightMode) .error {
      color: #FF6666;
    }

    #compiler:not(.lightMode) .warn {
      color: #FFFF66;
    }

    #compiler:not(.lightMode) .info {
      color: #74cbfb;
    }

    #compiler:not(.lightMode) .prompt {
      color: #99FF99;
    }

    .objinsp-summary {
      cursor: pointer;
      color: #d4d4d4;
    }

    #compiler:not(.darkMode) .objinsp-summary {
      color: #a19e9e;
    }

    summary {
      list-style: none;
      -webkit-appearance: none;
      appearance: none;
    }

    summary::-webkit-details-marker {
      display: none;
    }

    summary::marker {
      display: none;
    }

    details>summary::before {
      content: "▶";
      display: inline-block;
      margin-right: 5px;
      transition: transform 0.2s;
    }


    details[open]>summary::before {
      transform: rotate(90deg);
    }

    .isClone {
      cursor: default !important;
      pointer-events: none !important;
    }

    .outputContainer.isClone details>summary::before {
      font-family: "Symbol", Symbol, symbol;
      content: "Þ";
      display: inline-block;
      margin-right: 5px;
      transition: transform 0.2s;
      font-size: 13px;
    }

    .outputContainer.isClone details[open]>summary::before {
      font-family: "Symbol", Symbol, symbol;
      content: "ß";
      transform: none;
    }

    .objinsp-highlight-key {
      color: #9cdcfe;
      margin-left: 10px;
    }

    #compiler:not(.darkMode) .objinsp-highlight-key {
      color: #57c2fc;
    }

    .objinsp-highlight-string {
      color: #ce9178;
      display: ruby;
    }

    #compiler:not(.darkMode) .objinsp-highlight-string {
      color: #cc7b5a;
    }

    .objinsp-highlight-number {
      color: #b5cea8;
    }

    #compiler:not(.darkMode) .objinsp-highlight-number {
      color: #8f9d6a;
    }

    .objinsp-highlight-primitive {
      color: #ce9178;
    }

    #compiler:not(.darkMode) .objinsp-highlight-primitive {
      color: #cc7b5a;
    }

    .objinsp-highlight-type {
      color: #4ec9b0;
    }

    #compiler:not(.darkMode) .objinsp-highlight-type {
      color: #3aa99e;
    }

    .objinsp-highlight-value {
      color: #efd8d8;
    }

    #compiler:not(.darkMode) .objinsp-highlight-value {
      color: #1b1b1b;
    }

    .objinsp-node {
      color: #d4d4d4;
      margin-left: 10px;
    }

    #compiler:not(.darkMode) .objinsp-node {
      color: #000000;
    }

    .objinsp-dark:hover {
      background-color: rgba(0, 0, 0, 0.04);
    }

    .objinsp:hover {
      background-color: rgba(255, 255, 255, 0.04);
    }

    @media (max-width: 768px) {

      /* #sun {
        margin-left: 10px;
        margin-right: 10px;
      } */
      #activityBar {
        width: 40px;
      }

      #activityBar .icon {
        font-size: 18px;
        padding: 10px 0;
      }

      .sidebar-panel {
        width: 200px;
      }

      #runButton {
        padding: 6px 10px;
        font-size: 12px;
      }

      #statusBar {
        left: 50px;
      }

      .iPadShowKeyboard {
        display: none !important;
      }

      #activityBar .icon:hover:after {
        display: none;
      }

      #addTabButton {
        display: none;
      }

      #addTabButton_media {
        display: block;
      }
    }

    @media (max-width: 675px) {
      .sidebar-panel {
        width: 100%;
        padding-right: 50px;
        z-index: 1010;
        margin-top: 0px;
        padding-top: 46px;
      }
    }


    .monaco-editor .find-widget>.button.codicon-widget-close {
      top: 8px !important;
    }

    .lineNumber {
      vertical-align: middle;
      text-align: right;
      font-variant-numeric: tabular-nums;
      box-sizing: border-box;
      width: 50px;
      height: 100%;
    }

    .lineNumDark {
      color: rgb(133, 133, 133);
    }

    .lineNumLight {
      color: rgb(35, 120, 147);
    }

    .numberDiv {
      text-align: right;
      height: 18.9px;
      padding-right: 10px;
      padding-left: 18px;
    }

    .codeLineDiv {
      flex: 1;
      min-width: 0;
      overflow-wrap: anywhere;
      word-wrap: break-word;
      word-break: break-all;
      line-break: strict;
      hyphens: none;
      -webkit-hyphens: none;
      -moz-hyphens: none;
    }

    .outputItem {
      white-space: pre-wrap;
      display: flex;
      flex-wrap: wrap;
    }

    .symbolDiv {
      margin-right: 5px;
      flex-shrink: 0;
    }

    .flexContainer {
      display: flex;
      align-items: flex-start;
    }

    .previewModal {
      position: fixed;
      z-index: 9999;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.4);
      opacity: 0;
      pointer-events: none;
      transform: translateY(-100%);
      transition: transform 0.3s ease, opacity 0.5s ease;
    }

    .previewModal.active {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }


    .previewModal-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 10px;
      border: 1px solid;
      width: 80%;
      overflow: scroll;
      max-height: 80vh;
    }

    #compiler:not(.darkMode) .previewModal-content {
      background-color: #f0f0f0;
      border-color: #c0c0c0;
    }

    #compiler:not(.lightMode) .previewModal-content {
      background-color: #252526;
      border-color: #333;
    }


    #compiler:not(.darkMode) .previewModal-content::-webkit-scrollbar {
      width: 8px;
      background-color: #f0f0f0;
    }

    #compiler:not(.darkMode) .previewModal-content::-webkit-scrollbar-thumb {
      background-color: #c0c0c0;
      border-radius: 4px;
    }

    #compiler:not(.lightMode) .previewModal-content::-webkit-scrollbar {
      width: 8px;
      background-color: #252526;
    }

    #compiler:not(.lightMode) .previewModal-content::-webkit-scrollbar-thumb {
      background-color: #333;
      border-radius: 4px;
    }

    /* Dark Mode: corner matches dark background */
    #compiler:not(.lightMode) .previewModal-content::-webkit-scrollbar-corner {
      background-color: #252526;
      /* or #333, whichever matches your dark mode */
    }

    /* Light Mode: corner matches light background */
    #compiler:not(.darkMode) .previewModal-content::-webkit-scrollbar-corner {
      background-color: #f0f0f0;
      /* or #c0c0c0, whichever you prefer in light mode */
    }

    .modalClose {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
    }

    .modalClose:hover,
    .modalClose:focus {
      color: black;
      text-decoration: none;
      cursor: pointer;
    }

    body.lastTab .tab .close {
      visibility: hidden !important;
    }

    body.lastTab #allZip {
      display: none !important;
    }

    .exportBtnsWrapper {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }

    .form-check-input:checked {
      background-color: #3498db !important;
      cursor: pointer;
    }

    .form-check-custom {
      margin-bottom: 20px;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
    }

    .exportBtn {
      background-color: #0e639c;
      color: #ffffff;
      border: none;
      padding: 6px 12px;
      margin-top: 10px;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .exportBtn:hover {
      background-color: #1177bb;
    }

    .headerText {
      border: 2px solid;
      padding: 5px;
      margin: 20px;
      border: '1px solid';
      padding: '5px';
    }

    #compiler:not(.darkMode) .headerText {
      border-color: #c0c0c0;
    }

    #compiler:not(.lightMode) .headerText {

      border-color: #333;
    }

    .handPointer {
      cursor: pointer;
    }

    #compiler:not(.darkMode) .vs-navbar,
    #compiler:not(.darkMode) #activityBar,
    #compiler:not(.darkMode) #statusBar,
    #compiler:not(.darkMode) #tabBar {
      border-color: #c0c0c0;
    }

    #compiler:not(.lightMode) .vs-navbar,
    #compiler:not(.lightMode) #activityBar,
    #compiler:not(.lightMode) #statusBar,
    #compiler:not(.lightMode) #tabBar {
      border-color: #333;
    }

    .alertWrap {
      color: #e74c3c;
      text-align: center;
      align-items: center;
    }

    .alertButton {
      color: white;
      border: none;
      padding: 6px 12px;
      margin-top: 50px;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .alertText {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 10px;
    }

    .context-view li.action-item:nth-child(3),
    .context-view li.action-item:nth-child(6) {
      display: none !important;
    }

    .mobile-selections-container {
      position: absolute;
      top: 0;
      z-index: 9999;
    }

    .mobile-selections-container.hidden {
      display: none !important;
    }

    .mobile-selector {
      width: 25px;
      height: 25px;
      background: #7a77ff;
      position: absolute;
      border-radius: 50%;
      /* margin-top: 25px; */
      box-shadow: rgba(0, 0, 0, 0.35) 0px 5px 15px;
      touch-action: none;
    }

    .mobile-selector-right {
      border-top-left-radius: 0;
      margin-left: -8px;
    }

    .mobile-selector-left {
      border-top-right-radius: 0;
      margin-left: -35px;
    }

    .mobile-context-menu {
      position: absolute;
      display: flex;
      height: 40px;
      background: #333;
      border-radius: 18px;
      max-width: 220px;
      z-index: 999;
      user-select: none;
      color: #fff;
      touch-action: none;
    }

    #compiler:not(.darkMode) .mobile-context-menu {
      background: #f0f0f0;
      color: #000;
    }

    .mobile-context-menu.hidden {
      display: none !important;
    }


    .mobile-inset-menu {
      display: flex;
      max-width: 200px;
      padding-left: 5px;
      overflow: scroll;
    }

    .mobile-menu-item {
      position: relative;
      display: flex;
      padding: 0 16px;
      align-items: center;
      height: 100%;
      font-size: 14px;
      color: #fff;
      white-space: nowrap;
      line-height: 20px;
      transition: 0.2s;
    }

    #compiler:not(.darkMode) .mobile-menu-item {
      color: #000;
    }

    .mobile-menu-item.hovered {
      background: rgba(0, 0, 0, 0.25);
    }

    .mobile-arrow {
      position: absolute;
      width: 45px;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .mobile-arrow-left {
      left: 0;
      display: none;
    }

    .mobile-arrow-right {
      right: 0;
    }

    .mobile-arrow svg {
      width: 24px;
      height: 24px;
      fill: #000;
    }

    .ql-toolbar.ql-snow {
      margin: 20px 20px 10px;
      display: flex;
      gap: 30px;
      align-items: center;
      padding: 5px;
      padding-left: 5%;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      z-index: 10000;
    }

    #exportModal:not(.lightMode) .ql-toolbar.ql-snow {
      background-color: #333 !important;
      border-color: #555 !important;
    }

    #exportModal:not(.darkMode) .ql-toolbar.ql-snow {
      background-color: #f0f0f0 !important;
      border-color: #ccc !important;
    }

    .ql-toolbar.ql-snow button:focus,
    .ql-toolbar.ql-snow select:focus,
    .ql-toolbar.ql-snow input:focus {
      outline: none !important;
      box-shadow: none !important;
    }

    .ql-container {
      margin: 20px !important;
    }

    .ql-editor {
      padding: 10px !important;
    }

    #exportModal:not(.lightMode) .ql-toolbar.ql-snow button.ql-active {
      background-color: #5a5a5a !important;
    }

    #exportModal:not(.darkMode) .ql-toolbar.ql-snow button.ql-active {
      background-color: #c2c2c2 !important;
    }

    .ql-toolbar.ql-snow {
      margin: 20px 20px 10px;
      display: flex;
      gap: 30px;
      align-items: center;
      padding: 5px;
      padding-left: 5%;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      z-index: 10000;
    }

    .ql-toolbar.ql-snow button,
    .ql-toolbar.ql-snow select,
    .ql-toolbar.ql-snow input {
      margin-right: 5px;
      padding: 2px 5px;
      border: none;
      background: none;
      cursor: pointer;
    }

    .ql-toolbar.ql-snow button:hover {
      background: rgba(0, 0, 0, 0.1);
    }

    .ql-toolbar.ql-snow input[type="number"] {
      width: 60px;
      border: 1px solid;
    }

    .ql-toolbar.ql-snow input[type="color"] {
      width: 30px;
      height: 20px;
      padding: 0;
    }

    .ql-snow .ql-picker.ql-font {
      width: auto;
    }

    .ql-snow .ql-picker.ql-font .ql-picker-label::before,
    .ql-snow .ql-picker.ql-font .ql-picker-item::before {
      margin-right: 20px;
    }

    .ql-snow .ql-picker.ql-size {
      width: 60px;
    }

    .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="arial"]::before,
    .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="arial"]::before {
      content: 'Arial';
      font-family: Arial, sans-serif;
    }

    .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="times-new-roman"]::before,
    .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="times-new-roman"]::before {
      content: 'Times New Roman';
      font-family: "Times New Roman", serif;
    }

    .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="courier-new"]::before,
    .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="courier-new"]::before {
      content: 'Courier New';
      font-family: "Courier New", monospace;
    }

    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value="8px"]::before,
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value="8px"]::before {
      content: '8px';
    }

    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value="12px"]::before,
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value="12px"]::before {
      content: '12px';
    }

    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value="16px"]::before,
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value="16px"]::before {
      content: '16px';
    }

    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value="20px"]::before,
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value="20px"]::before {
      content: '20px';
    }

    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value="24px"]::before,
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value="24px"]::before {
      content: '24px';
    }

    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value="32px"]::before,
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value="32px"]::before {
      content: '32px';
    }

    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value="36px"]::before,
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value="36px"]::before {
      content: '36px';
    }

    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value="48px"]::before,
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value="48px"]::before {
      content: '48px';
    }

    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value="64px"]::before,
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value="64px"]::before {
      content: '64px';
    }

    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value="72px"]::before,
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value="72px"]::before {
      content: '72px';
    }

    #exportModal:not(.lightMode) .ql-editor.ql-blank:before {
      color: #ffffff;
    }

    #exportModal:not(.darkMode) .ql-editor.ql-blank:before {
      color: #000000;
    }

    #exportModal:not(.darkMode) .ql-font .ql-picker-label,
    #exportModal:not(.darkMode) .ql-size .ql-picker-label,
    #exportModal:not(.darkMode) .ql-color .ql-picker-label,
    #exportModal:not(.darkMode) .ql-align .ql-picker-label {
      color: #000000 !important;
    }

    #exportModal:not(.lightMode) .ql-font .ql-picker-label,
    #exportModal:not(.lightMode) .ql-size .ql-picker-label,
    #exportModal:not(.lightMode) .ql-color .ql-picker-label,
    #exportModal:not(.lightMode) .ql-align .ql-picker-label {
      color: #ffffff !important;
    }

    #exportModal:not(.lightMode) .ql-font .ql-picker-label svg *,
    #exportModal:not(.lightMode) .ql-size .ql-picker-label svg *,
    #exportModal:not(.lightMode) .ql-color .ql-picker-label svg *,
    #exportModal:not(.lightMode) .ql-align .ql-picker-label svg * {
      stroke: #ffffff;
    }

    #exportModal:not(.lightMode) .ql-direction svg * {
      stroke: #ffffff !important;
    }

    #exportModal:not(.darkMode) .ql-font .ql-picker-label svg *,
    #exportModal:not(.darkMode) .ql-size .ql-picker-label svg *,
    #exportModal:not(.darkMode) .ql-color .ql-picker-label svg *,
    #exportModal:not(.darkMode) .ql-align .ql-picker-label svg * {
      stroke: #000000;
    }

    #exportModal:not(.darkMode) .ql-direction svg * {
      stroke: #000000 !important;
    }

    #exportModal:not(.darkMode) .ql-color-label.ql-stroke.ql-transparent {
      stroke: #000000;
    }

    #exportModal:not(.lightMode) .ql-color-label.ql-stroke.ql-transparent {
      stroke: #ffffff;
    }

    .ql-editor {
      font-size: 16px;
    }

    #exportModal:not(.darkMode) .ql-underline svg *,
    #exportModal:not(.darkMode) .ql-bold svg *,
    #exportModal:not(.darkMode) .ql-italic svg * {
      stroke: #000000
    }

    #exportModal:not(.lightMode) .ql-underline svg *,
    #exportModal:not(.lightMode) .ql-bold svg *,
    #exportModal:not(.lightMode) .ql-italic svg * {
      stroke: #ffffff
    }

    @media (max-width: 900px) {

      .previewModal-content {
        width: 90%;
        max-height: 90vh;
      }

      .previewModal-content img {
        max-width: 100%;
        height: auto;
      }

      /* Smaller toolbar container */
      .ql-toolbar.ql-snow {
        margin: 10px 10px 5px;
        gap: 10px;
        padding: 3px;
        padding-left: 5px;
        border-radius: 3px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
      }

      /* Reduce button, select, and input sizes */
      .ql-toolbar.ql-snow button,
      .ql-toolbar.ql-snow select,
      .ql-toolbar.ql-snow input {
        margin-right: 3px;
        padding: 2px 3px;
        font-size: 12px;
      }

      /* Adjust number inputs */
      .ql-toolbar.ql-snow input[type="number"] {
        width: 50px;
      }

      /* Adjust color inputs */
      .ql-toolbar.ql-snow input[type="color"] {
        width: 25px;
        height: 15px;
      }

      /* Optional: reduce margins on the editor container */
      .ql-container {
        margin: 10px !important;
      }

      /* Optional: adjust the editor text size and padding */
      .ql-editor {
        padding: 5px !important;
        font-size: 14px !important;
      }
    }

    @media (max-width: 700px) {

      /* Adjust toolbar for smaller screens */
      .ql-toolbar.ql-snow {
        flex-wrap: wrap;
        gap: 5px;
      }

      /* Adjust button sizes */
      .ql-toolbar.ql-snow button,
      .ql-toolbar.ql-snow select,
      .ql-toolbar.ql-snow input {
        padding: 2px 2px;
        font-size: 10px;
      }

      /* Adjust number inputs */
      .ql-toolbar.ql-snow input[type="number"] {
        width: 40px;
      }

      /* Adjust color inputs */
      .ql-toolbar.ql-snow input[type="color"] {
        width: 20px;
        height: 12px;
      }

    }
  </style>

  <script>alert(2);</script>
</head>

<body>
  <div id="compiler" class="darkMode">
    <div class="vs-logo">
      <img src="{% static 'site_images/jseditor.png' %}" alt="Logo" />
    </div>
    <div class="vs-navbar">
      <div class="vs-navbar-item" data-dropdown="fileDropdown">
        File
        <div class="vs-navbar-dropdown" id="fileDropdown">
          <div class="vs-navbar-dropdown-item" id="uploadFileBtn">Upload File</div>
          <div class="vs-navbar-dropdown-item" id="saveScriptBtn">Save File</div>
        </div>
      </div>
      <div class="vs-navbar-item" data-dropdown="editDropdown">
        Edit
        <div class="vs-navbar-dropdown" id="editDropdown">
          <div class="vs-navbar-dropdown-item" id="selectAllBtn">Select All</div>
        </div>
      </div>
      <div id="undoBtn"><i class="fa-solid fa-arrow-rotate-left"></i></div>
      <div id="redoBtn"><i class="fa-solid fa-rotate-right"></i></div>
      <button id="runButton" onclick="runTab()">
        <i class="fas fa-play"></i> Run
      </button>
      <div id="addTabButton"><i class="fas fa-plus"></i></div>
      <div id="lightModeDiv" onclick="changeToLightMode()">
        <i id="sun" class="fa-solid fa-sun"></i>
      </div>
      <div id="fullScreenBtn" onclick="fullScreen()">
        <i class="fa-solid fa-up-right-and-down-left-from-center"></i>
      </div>
    </div>
    <div id="activityBar">
      <div id="addTabButton_media"><i class="fas fa-plus"></i></div>
      <div class="icon" id="searchIcon" data-label="Search" data-target="searchPanel">
        <i class="fas fa-search"></i>
      </div>
      <div class="icon" id="gitIcon" data-label="Source Control" data-target="gitPanel">
        <i class="fas fa-code-branch"></i>
      </div>
      <div class="icon" id="settingsIcon" data-label="Settings" data-target="settingsPanel">
        <i class="fas fa-cog"></i>
      </div>
      <div class="icon" id="exportIcon" data-label="Export" data-target="exportPanel">
        <i class="fas fa-file-export"></i>
      </div>
    </div>

    <div id="gitPanel" class="sidebar-panel">
      <input type="url" id="gitUrl" placeholder="Enter GitHub file URL" />
      <button id="loadGitButton" disabled="true">Load</button>
    </div>
    <div id="settingsPanel" class="sidebar-panel">
      <div>
        <label for="tabSizeInput">Tab Size: <span id="tabSizeDisplay">3</span></label>
        <input id="tabSizeInput" type="range" min="1" max="8" value="3" class="vs-range" />
        <div class="form-check-custom">
          <input class="form-check-input" type="checkbox" id="flexSwitchCheckDefault" style="margin-top: 10px;">
          <label class="form-check-label" for="flexSwitchCheckDefault">Terminate Worker</label>
          <button class="vs-button" style="margin-top: 10px;" onclick="saveSettings()" id="saveSettingsBtn">Save
            settings</button>
        </div>
      </div>
    </div>
    <div id="exportPanel" class="sidebar-panel">
      <div class="exportBtnsWrapper">
        <select id="exportSelect">
          <option value="current">Download Current Script</option>
          <option id="allZip" value="allZip">Download All Scripts (zip)</option>
          <option value="image">Export as Image</option>
          <option value="pdf">Export as PDF</option>
        </select>
        <button id="exportButton" class="vs-button" onclick="exportCode()">Export</button>
      </div>
    </div>
    <div id="mainContainer">
      <div id="tabBar"></div>
      <div id="tabsContainer"></div>
      <div id="statusBar">
        <div class="status-item" id="statusPosition">Ln 1, Col 1</div>
        <div class="status-item">UTF-8</div>
        <div class="status-item" id="statusSpaces">Spaces: 3</div>
        <div class="status-item">JavaScript</div>
      </div>
    </div>
    <div id="exportModal" class="previewModal darkMode">
      <div class="previewModal-content" id="exportModalContent">
      </div>
    </div>
  </div>



  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script>
  <script>
    console.warn = () => { };
    const workerPath = "{% url 'betzi_test_js' %}";
    const { jsPDF } = window.jspdf;
    let currentTab = null;
    let workerBlobURL = null;
    let activeDropdown = null;
    let spaces = 3;
    let tabs = [];
    let activeTabId = null;
    let draggedTabId = null;
    let lastDropSide = null;
    let darkModeFlag = true;
    let nextWorker;
    let tabSizeInput = document.getElementById("tabSizeInput");
    let tabSizeDisplay = document.getElementById("tabSizeDisplay");
    const compiler = document.getElementById("compiler");
    const exportSelect = document.getElementById("exportSelect");
    const flexSwitchCheckDefault = document.getElementById("flexSwitchCheckDefault");
    const modal = document.getElementById("exportModal");
    const exportModalContent = document.getElementById("exportModalContent");

    let isMobile;
    function isMobileDevice() {
      const userAgent = navigator.userAgent || navigator.vendor || window.opera;
      return /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());
    }
    isMobile = isMobileDevice();
    if (isMobile) {
      compiler.style.width = '100%';
      compiler.style.height = '100vh';
      compiler.style.margin = '0';
    } else {
      window.onload = function () {
        compiler.style.width = '60%';
        fullScreen();
      };
    }


    function stopAll(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      event.stopPropagation();
    }

    function fullScreen() {
      if (compiler.style.width === "60%") {
        compiler.style.width = "100%";
        compiler.style.height = "100vh";
        compiler.style.margin = "0";
      } else {
        compiler.style.width = "60%";
        compiler.style.height = "500px";
        compiler.style.margin = '100px auto';
      }
    }
    document.addEventListener('keydown', function (event) {
      if (compiler.style.width === "100%") {
        if (event.key === 'Escape' && modalIsOpen()) {
          closeModal("close");
        } else if (event.key === 'Escape') {
          compiler.style.width = "60%";
          compiler.style.height = "500px";
          compiler.style.margin = '100px auto';
        }
      }
    });

    function saveSettings() {
      localStorage.setItem("tabSize", spaces);
      localStorage.setItem("terminateWorker", flexSwitchCheckDefault.checked);
      localStorage.setItem("darkMode", darkModeFlag);
      const saveSettingsBtn = document.getElementById("saveSettingsBtn");
      saveSettingsBtn.disabled = true;
      saveSettingsBtn.style.width = saveSettingsBtn.offsetWidth + "px";
      saveSettingsBtn.textContent = "Saved!";
      setTimeout(() => {
        saveSettingsBtn.textContent = "Save settings";
        saveSettingsBtn.disabled = false;
        saveSettingsBtn.style.width = "auto";
      }, 1000);
    }

    function loadSettings() {
      const tabSize = localStorage.getItem("tabSize");
      if (tabSize) {
        spaces = parseInt(tabSize);
        tabSizeInput.value = spaces;
        tabSizeDisplay.textContent = spaces;
        tabSizeInput.dispatchEvent(new Event("input"));
      }
      const terminateWorker = localStorage.getItem("terminateWorker");
      if (terminateWorker) {
        flexSwitchCheckDefault.checked = terminateWorker === "true";
      }
      if (localStorage.getItem("darkMode") === "false") {
        changeToLightMode();
      }
    }

    const lightModeDiv = document.getElementById("lightModeDiv");

    function changeToLightMode() {
      if (darkModeFlag) {

        document.getElementById('compiler').classList.add("lightMode");
        document.getElementById('compiler').classList.remove("darkMode");
        modal.classList.add("lightMode");
        modal.classList.remove("darkMode");

        darkModeFlag = false;

        lightModeDiv.innerHTML = '<i id="moon" class="fa-solid fa-moon"></i>';
        monaco.editor.setTheme("custom-light");

      } else {

        document.getElementById('compiler').classList.remove("lightMode");
        document.getElementById('compiler').classList.add("darkMode");
        modal.classList.remove("lightMode");
        modal.classList.add("darkMode");

        lightModeDiv.innerHTML = '<i id="sun" class="fa-solid fa-sun"></i>';
        darkModeFlag = true;
        monaco.editor.setTheme("custom-dark");
      }
      updateUndoRedoButtons();
    }


    function reorderTabsByTab(dId, tId, side) {
      let dIndex = tabs.findIndex((x) => x.id === dId);
      let tIndex = tabs.findIndex((x) => x.id === tId);
      if (dIndex < 0 || tIndex < 0) return;
      let removed = tabs.splice(dIndex, 1)[0];
      let newI = tIndex + (side === "right" ? 1 : 0);
      if (dIndex < tIndex) newI--;
      tabs.splice(newI, 0, removed);
      let b = document.getElementById("tabBar");
      tabs.forEach((x) => {
        b.appendChild(x.tabElement);
      });
    }

    function createTab(desiredName = null, content = null) {
      let wasDragging = false;
      let lastTouchY = null;
      let dragTouchX = null;
      let dragTouchY = null;
      let contextDiv = null;
      let becasueTouch = false;
      let theContext;
      let isContextDragged = false;
      let editorRectGlobal = null;
      let doShow = { show: false, x: 0, y: 0 };
      let showContextFunc = null;
      let setContextPosFunc = null;

      function getRect() {
        if (editorRectGlobal === null) {
          editorRectGlobal = editorInstance.getDomNode().getBoundingClientRect();
        }
        return editorRectGlobal;
      }

      function initializeMobileSelection(editorInstance) {
        const editorDom = editorInstance.getDomNode();
        if (!editorDom) return;

        const mobileSelectionsContainer = document.createElement('div');
        mobileSelectionsContainer.className = 'mobile-selections-container hidden';
        const mobileSelectorRight = document.createElement('div');
        mobileSelectorRight.className = 'mobile-selector mobile-selector-right';
        const mobileSelectorLeft = document.createElement('div');
        mobileSelectorLeft.className = 'mobile-selector mobile-selector-left';
        mobileSelectionsContainer.appendChild(mobileSelectorRight);
        mobileSelectionsContainer.appendChild(mobileSelectorLeft);

        const editorScrollable = editorDom;
        editorScrollable.insertAdjacentElement('afterbegin', mobileSelectionsContainer);

        const mobileContextMenu = document.createElement('div');
        mobileContextMenu.className = 'mobile-context-menu hidden';
        theContext = mobileContextMenu;
        const mobileInsetMenu = document.createElement('div');
        mobileInsetMenu.className = 'mobile-inset-menu';

        let touchStartX = 0, touchStartY = 0;
        let menuStartX = 0, menuStartY = 0;
        let touchOffsetX = 0, touchOffsetY = 0;

        mobileContextMenu.addEventListener('touchstart', (e) => {
          stopAll(e);
          const touch = e.touches[0];
          const editorRect = getRect();
          touchStartX = touch.clientX;
          touchStartY = touch.clientY;
          menuStartX = mobileContextMenu.offsetLeft;
          menuStartY = mobileContextMenu.offsetTop;

          const menuRect = mobileContextMenu.getBoundingClientRect();
          touchOffsetX = touch.clientX - menuRect.left;
          touchOffsetY = touch.clientY - menuRect.top;
        });

        mobileContextMenu.addEventListener('touchmove', (e) => {
          stopAll(e);
          const touch = e.touches[0];
          const deltaX = touch.clientX - touchStartX;
          const deltaY = touch.clientY - touchStartY;

          if (!isContextDragged && Math.abs(deltaX) < 5 && Math.abs(deltaY) < 5) {
            return;
          }

          isContextDragged = true;
          const menuWidth = mobileContextMenu.offsetWidth;
          const menuHeight = mobileContextMenu.offsetHeight;
          const editorRect = getRect();
          const initialCenterX = menuStartX + menuWidth / 2;
          const initialCenterY = menuStartY + menuHeight / 2;
          const newCenterX = initialCenterX + deltaX;
          const newCenterY = initialCenterY + deltaY;
          const newX = newCenterX - menuWidth / 2;
          const newY = newCenterY - menuHeight / 2;
          const maxX = editorRect.width - menuWidth;
          const maxY = editorRect.height - menuHeight;
          const constrainedX = Math.max(0, Math.min(newX, maxX));
          const constrainedY = Math.max(0, Math.min(newY, maxY));
          setContextPos(constrainedX, constrainedY);
        });


        mobileContextMenu.addEventListener('touchend', (e) => {
          stopAll(e);
          const touch = e.changedTouches[0];
          const touchEndX = touch.clientX;
          const touchEndY = touch.clientY;
          if (Math.abs(touchEndX - touchStartX) < 10 && Math.abs(touchEndY - touchStartY) < 10) {
            becasueTouch = true;
          }
          setTimeout(() => {
            becasueTouch = false;
            isContextDragged = false;
          }, 100);
        }, { passive: false });


        document.addEventListener('touchstart', (e) => {
          if (!isContextMenuOpen()) {
            return;
          }
          if (!contextDiv.contains(e.target)) {
            mobileContextMenu.classList.add('hidden');
            editorInstance.setSelection(new monaco.Selection(0, 0, 0, 0));
          }
        });

        mobileContextMenu.appendChild(mobileInsetMenu);
        editorScrollable.insertAdjacentElement('afterbegin', mobileContextMenu);
        contextDiv = mobileContextMenu

        editorInstance.onDidChangeCursorSelection((e) => {
          const selection = e.selection;
          if (selection.isEmpty()) {
            mobileSelectionsContainer.classList.add('hidden');
            mobileContextMenu.classList.add('hidden');
            return;
          }
          const startPos = selection.getStartPosition();
          const endPos = selection.getEndPosition();
          const startCoords = editorInstance.getScrolledVisiblePosition(startPos);
          const endCoords = editorInstance.getScrolledVisiblePosition(endPos);

          if (!isContextMenuOpen()) {
            showContextMenu();
            positionContextMenu(startCoords, endCoords);
          }
          if (startCoords && endCoords) {
            mobileSelectorLeft.style.transform = `translate(${startCoords.left + 10}px, ${startCoords.top + 22}px)`;
            mobileSelectorRight.style.transform = `translate(${endCoords.left + 10}px, ${endCoords.top + 22}px)`;
            if (!wasDragging) {
              mobileSelectorRight.style.visibility = 'visible';
              mobileSelectorLeft.style.visibility = 'visible';
            }
            mobileSelectionsContainer.classList.remove('hidden');
          }
        });

        function isContextMenuOpen() {
          return !mobileContextMenu.classList.contains('hidden') || becasueTouch;
        }

        function setContextPos(x, y) {
          const theRect = getRect();
          const menuHeight = mobileContextMenu.offsetHeight || 40;
          const maxX = theRect.width - mobileContextMenu.offsetWidth;
          const maxY = theRect.height - menuHeight;

          let constrainedX = Math.max(0, Math.min(x, maxX));
          let constrainedY = Math.max(0, Math.min(y, maxY));

          if (isContextDragged) {
            if (constrainedY + menuHeight > theRect.height) {
              constrainedY = Math.max(0, y - menuHeight);
            }
          }

          mobileContextMenu.style.left = `${constrainedX}px`;
          mobileContextMenu.style.top = `${constrainedY}px`;
        }
        showContextFunc = showContextMenu;

        function positionContextMenu(startCoords, endCoords, event = null) {
          const theRect = getRect();
          const menuWidth = mobileContextMenu.offsetWidth || 200;
          const menuHeight = mobileContextMenu.offsetHeight || 40;
          const selectorHeight = 25;
          let x, y;

          if (startCoords && endCoords) {
            const selectionCenterX = (startCoords.left + endCoords.left) / 2 - menuWidth / 2;
            const selectionTopY = Math.min(startCoords.top, endCoords.top);
            const selectionBottomY = Math.max(startCoords.top, endCoords.top) + selectorHeight;
            const selectionHeight = selectionBottomY - selectionTopY;

            const editorVisibleHeight = theRect.height;
            if (selectionHeight > editorVisibleHeight * 0.8) {
              x = (theRect.width - menuWidth) / 2;
              y = (theRect.height - menuHeight) / 2;
            } else {
              const spaceAbove = selectionTopY;
              if (spaceAbove >= menuHeight + 5) {
                x = selectionCenterX;
                y = selectionTopY - menuHeight - 5;
              } else {
                x = selectionCenterX;
                y = selectionTopY + selectorHeight + 20;
                const spaceBelow = theRect.height - selectionBottomY;
                if (spaceBelow < selectorHeight + 5) {
                  y = Math.max(0, selectionBottomY - menuHeight - selectorHeight - 5);
                }
              }
            }
          } else {
            if (event) {
              const touch = event.touches ? event.touches[0] : event;
              x = touch.clientX - theRect.left - menuWidth / 2;
              y = touch.clientY - theRect.top - menuHeight - 5;
              if (y < 0) {
                y = touch.clientY - theRect.top + 5;
              }
            } else {
              const cursorPos = editorInstance.getPosition();
              if (cursorPos) {
                const coords = editorInstance.getScrolledVisiblePosition(cursorPos);
                if (coords) {
                  x = coords.left - menuWidth / 2;
                  y = coords.top - menuHeight - 5;
                  if (y < 0) {
                    y = coords.top + 20;
                  }
                }
              }
              if (!cursorPos || !coords) {
                if (dragTouchY !== null) {
                  x = dragTouchX - theRect.left - menuWidth / 2;
                  y = dragTouchY - theRect.top - menuHeight - 5;
                  if (y < 0) {
                    y = dragTouchY - theRect.top + 5;
                  }
                } else {
                  x = (theRect.width - menuWidth) / 2;
                  y = (theRect.height - menuHeight) / 2;
                }
              }
            }
          }

          setContextPos(x, y);
        }

        function funcDeco(func) {
          return () => {
            if (isContextDragged) {
              return;
            }
            func()
          }
        }
        function showContextMenu(options) {
          if (isContextMenuOpen()) return;
          const theModel = editorInstance.getModel();
          const isTextSelected = theModel.getValueInRange(editorInstance.getSelection()) !== '';
          const defaultOptions = {
            copy: isTextSelected,
            cut: isTextSelected,
            paste: true,
            selectAll: true,
            format: true
          };
          options = Object.assign({}, defaultOptions, options);
          const menuItems = [
            { className: 'copy', text: 'Copy', action: funcDeco(() => editorInstance.trigger('source', 'editor.action.clipboardCopyAction')), close: false },
            { className: 'cut', text: 'Cut', action: funcDeco(() => editorInstance.trigger('source', 'editor.action.clipboardCutAction')), close: true },
            { className: 'paste', text: 'Paste', action: funcDeco(() => editorInstance.trigger('source', 'editor.action.clipboardPasteAction')), close: true },
            {
              className: 'selectAll', text: 'Select All', action: funcDeco(() => {
                const range = editorInstance.getModel().getFullModelRange();
                editorInstance.setSelection(range);
              })
              , close: true
            },
            { className: 'format', text: 'Format', action: funcDeco(() => editorInstance.getAction('editor.action.formatDocument').run()), close: false }
          ];
          const menuItemsFiltered = menuItems.filter(item => options[item.className]);
          mobileInsetMenu.innerHTML = '';
          mobileInsetMenu.style.display = 'flex';
          mobileInsetMenu.style.overflowX = 'hidden';
          mobileInsetMenu.style.flexWrap = 'nowrap';
          mobileInsetMenu.style.width = 'calc(100% - 40px)';

          menuItemsFiltered.forEach(item => {
            const menuItem = document.createElement('div');
            menuItem.className = 'mobile-menu-item ' + item.className;
            menuItem.innerHTML = `<span>${item.text}</span>`;
            menuItem.addEventListener('touchstart', (e) => {
              menuItem.classList.add('hovered');
            }, { passive: false });

            menuItem.addEventListener('touchmove', (e) => {
              menuItem.classList.remove('hovered');
            }, { passive: false });

            menuItem.addEventListener('touchend', (e) => {
              stopAll(e);
              if (item.close && !isContextDragged) {
                mobileContextMenu.classList.add('hidden');
              }
              menuItem.classList.remove('hovered');
              item.action();
            }, { passive: false });

            mobileInsetMenu.appendChild(menuItem);
          });

          const existingArrow = mobileContextMenu.querySelector('.toggle-arrow');
          if (existingArrow) existingArrow.remove();

          setTimeout(() => {
            if (mobileInsetMenu.scrollWidth > mobileInsetMenu.clientWidth) {
              let arrow = document.createElement('div');
              arrow.className = 'mobile-menu-item toggle-arrow';
              arrow.style.display = 'flex';
              arrow.style.alignItems = 'center';
              arrow.style.justifyContent = 'center';
              arrow.style.width = '40px';
              arrow.innerHTML = `<span style="display:inline-block; transition: transform 0.3s;">&#9654;</span>`;

              let isAtEnd = false;
              arrow.addEventListener('touchstart', (e) => {
                arrow.classList.add('hovered');
              }, { passive: false });

              arrow.addEventListener('touchmove', (e) => {
                arrow.classList.remove('hovered');
              }, { passive: false });

              arrow.addEventListener('touchend', (e) => {
                stopAll(e);
                if (isContextDragged) return;
                arrow.classList.remove('hovered');
                if (!isAtEnd) {
                  mobileInsetMenu.scrollTo({ left: mobileInsetMenu.scrollWidth, behavior: 'smooth' });
                  isAtEnd = true;
                  arrow.innerHTML = `<span style="display:inline-block; transition: transform 0.3s; transform: rotate(180deg);">&#9654;</span>`;
                } else {
                  mobileInsetMenu.scrollTo({ left: 0, behavior: 'smooth' });
                  isAtEnd = false;
                  arrow.innerHTML = `<span style="display:inline-block; transition: transform 0.3s; transform: rotate(0deg);">&#9654;</span>`;
                }
              }, { passive: false });

              mobileContextMenu.appendChild(arrow);
            }
          }, 0);

          mobileContextMenu.classList.remove('hidden');
          if (!isTextSelected && dragTouchY !== null) {
            positionContextMenu(null, null, { clientX: dragTouchX, clientY: dragTouchY });
          }

        }
        showContextFunc = showContextMenu;

        function handleMobileSelectorTouch(selector, isLeft) {
          let touchStartPos, initialSelection;
          let touchMoved = false, touchEndTimeout;
          selector.addEventListener('touchstart', (event) => {
            event.preventDefault();
            wasDragging = true;
            const touch = event.touches[0];
            touchStartPos = { x: touch.clientX, y: touch.clientY };
            initialSelection = editorInstance.getSelection();
            touchMoved = false;
            if (touchEndTimeout) clearTimeout(touchEndTimeout);
            becasueTouch = true;
            mobileContextMenu.classList.add('hidden');
          }, { passive: false });

          let autoScrollInterval = null;
          const autoScrollDelay = 20;

          selector.addEventListener('touchmove', (event) => {
            stopAll(event);
            const touch = event.touches[0];
            const target = editorInstance.getTargetAtClientPoint(touch.clientX, touch.clientY);
            if (target && target.position) {
              const newSelection = isLeft
                ? new monaco.Selection(
                  target.position.lineNumber,
                  target.position.column,
                  initialSelection.endLineNumber,
                  initialSelection.endColumn
                )
                : new monaco.Selection(
                  initialSelection.startLineNumber,
                  initialSelection.startColumn,
                  target.position.lineNumber,
                  target.position.column
                );
              editorInstance.setSelection(newSelection);
              touchMoved = true;
            }

            const editorScrollable = domNode;
            const editorRect = getRect();
            const threshold = 50;
            const scrollStep = 6;
            if (touch.clientY >= editorRect.top + threshold && touch.clientY <= editorRect.bottom - threshold) {
              if (autoScrollInterval !== null) {
                clearInterval(autoScrollInterval);
                autoScrollInterval = null;
              }
            } else {
              if (autoScrollInterval === null) {
                autoScrollInterval = setInterval(() => {
                  if (lastTouchY !== null) {
                    if (lastTouchY < editorRect.top + threshold) {
                      editorInstance.setScrollTop(editorInstance.getScrollTop() - scrollStep);
                    } else if (lastTouchY > editorRect.bottom - threshold) {
                      editorInstance.setScrollTop(editorInstance.getScrollTop() + scrollStep);
                    }
                  }
                }, autoScrollDelay);
              }
            }
            lastTouchY = touch.clientY;
          }, { passive: false });

          selector.addEventListener('touchend', (event) => {
            if (autoScrollInterval !== null) {
              clearInterval(autoScrollInterval);
              autoScrollInterval = null;
            }
            if (!touchMoved) {
              const touch = event.changedTouches[0];
              const target = editorInstance.getTargetAtClientPoint(touch.clientX, touch.clientY);
              if (target && target.position) {
                const newSelection = isLeft
                  ? new monaco.Selection(target.position.lineNumber, target.position.column, initialSelection.endLineNumber, initialSelection.endColumn)
                  : new monaco.Selection(initialSelection.startLineNumber, initialSelection.startColumn, target.position.lineNumber, target.position.column);
                editorInstance.setSelection(newSelection);
              }
            }
            touchStartPos = null;
            initialSelection = null;
            touchMoved = false;
          });

        }


        handleMobileSelectorTouch(mobileSelectorLeft, true);
        handleMobileSelectorTouch(mobileSelectorRight, false);
        function fitScroll() {
          const selection = editorInstance.getSelection();
          if (!selection || selection.isEmpty()) {
            mobileSelectionsContainer.classList.add('hidden');
            mobileContextMenu.classList.add('hidden');
            return;
          }

          const startPos = selection.getStartPosition();
          const endPos = selection.getEndPosition();
          const startCoords = editorInstance.getScrolledVisiblePosition(startPos);
          const endCoords = editorInstance.getScrolledVisiblePosition(endPos);

          if (startCoords && endCoords) {
            const offsetX = 10, offsetY = 22;
            const reverseOffset = 20;
            const editorScrollable = domNode
            const scrollRect = getRect();

            const leftHandlePos = startCoords.top + offsetY;
            const spaceBelowLeft = scrollRect.bottom - leftHandlePos;
            if (spaceBelowLeft < 50) {
              mobileSelectorLeft.style.visibility = 'hidden';
            } else if (spaceBelowLeft >= 50 && spaceBelowLeft < 90) {
              mobileSelectorLeft.style.visibility = 'visible';
              mobileSelectorLeft.style.transform = `translate(${startCoords.left + offsetX}px, ${startCoords.top - reverseOffset}px) rotate(+90deg)`;
            } else {
              mobileSelectorLeft.style.visibility = 'visible';
              mobileSelectorLeft.style.transform = `translate(${startCoords.left + offsetX}px, ${startCoords.top + offsetY}px) rotate(0deg)`;
            }

            const rightHandlePos = endCoords.top + offsetY;
            const spaceBelowRight = scrollRect.bottom - rightHandlePos;
            if (spaceBelowRight < 50) {
              mobileSelectorRight.style.visibility = 'hidden';
            } else if (spaceBelowRight >= 50 && spaceBelowRight < 90) {
              mobileSelectorRight.style.visibility = 'visible';
              mobileSelectorRight.style.transform = `translate(${endCoords.left + offsetX}px, ${endCoords.top - reverseOffset}px) rotate(-90deg)`;
            } else {
              mobileSelectorRight.style.visibility = 'visible';
              mobileSelectorRight.style.transform = `translate(${endCoords.left + offsetX}px, ${endCoords.top + offsetY}px) rotate(0deg)`;
            }

            mobileSelectionsContainer.classList.remove('hidden');
          }
        }
        editorInstance.onDidScrollChange(fitScroll);

        let longPressTimeout, startPositionLP;
        editorDom.addEventListener('touchstart', (event) => {
          const touch = event.touches[0];
          const initialTouchX = touch.clientX;
          const initialTouchY = touch.clientY;
          let currentTouchX = initialTouchX;
          let currentTouchY = initialTouchY;
          let hasMovedSignificantly = false;
          const threshold = 10;
          if (mobileContextMenu.contains(event.target) || mobileSelectionsContainer.contains(event.target)) {
            event.stopPropagation();
            event.preventDefault();
            return;
          }

          clearTimeout(longPressTimeout);
          const touchMoveHandler = (moveEvent) => {
            const moveTouch = moveEvent.touches[0];
            currentTouchX = moveTouch.clientX;
            currentTouchY = moveTouch.clientY;

            const deltaX = Math.abs(currentTouchX - initialTouchX);
            const deltaY = Math.abs(currentTouchY - initialTouchY);
            if (deltaX > threshold || deltaY > threshold) {
              hasMovedSignificantly = true;
            }
          };

          const touchEndHandler = () => {
            editorDom.removeEventListener('touchmove', touchMoveHandler);
            editorDom.removeEventListener('touchend', touchEndHandler);
            if (longPressTimeout) {
              clearTimeout(longPressTimeout);
            }
          };
          editorDom.addEventListener('touchmove', touchMoveHandler, { passive: false });
          editorDom.addEventListener('touchend', touchEndHandler, { passive: false });

          longPressTimeout = setTimeout(() => {
            editorDom.removeEventListener('touchmove', touchMoveHandler);
            editorDom.removeEventListener('touchend', touchEndHandler);

            if (!hasMovedSignificantly) {
              if (!isContextMenuOpen()) {
                if (editorInstance.getSelection().isEmpty()) {
                  const target = editorInstance.getTargetAtClientPoint(currentTouchX, currentTouchY);
                  if (target && target.position) {
                    editorInstance.setPosition(target.position);
                    editorInstance.focus();
                  }
                }
                const editorRect = getRect();
                const menuWidth = mobileContextMenu.offsetWidth || 200;
                const menuHeight = mobileContextMenu.offsetHeight || 40;
                const x = currentTouchX - editorRect.left - menuWidth / 2;
                const y = currentTouchY - editorRect.top - menuHeight - 5;
                doShow.show = true;
                doShow.x = x;
                doShow.y = y;
              }
            }
          }, 1000);

          const target = editorInstance.getTargetAtClientPoint(touch.clientX, touch.clientY);
          if (target && target.position) {
            startPositionLP = target.position;
          }
        }, { passive: false });
        fitScroll();
        stopAll(event)
      }
      let name = desiredName
        ? getUniqueTabName(desiredName)
        : getNextTabName();
      let id = Date.now();
      let sharedBuffer = new SharedArrayBuffer(1024);
      let view = new Int32Array(sharedBuffer);
      let tabEl = document.createElement("div");
      tabEl.classList.add("tab");
      tabEl.draggable = true;
      let titleSpan = document.createElement("span");
      titleSpan.classList.add("tab-title");
      titleSpan.textContent = name;
      tabEl.appendChild(titleSpan);
      let closeIcon = document.createElement("i");
      closeIcon.classList.add("fas", "fa-times", "close");
      tabEl.appendChild(closeIcon);
      let editorOutputWrapper = document.createElement("div");
      editorOutputWrapper.classList.add("editor-and-output");
      let editorContainer = document.createElement("div");
      editorContainer.classList.add("editorContainer");
      editorOutputWrapper.appendChild(editorContainer);
      let outputContainer = document.createElement("div");
      outputContainer.classList.add("outputContainer");
      outputContainer.classList.add("allowSelect")
      outputContainer.classList.add("resize");
      let controlsBar = document.createElement("div");
      controlsBar.classList.add("controls");
      outputContainer.appendChild(controlsBar);

      controlsBar.addEventListener('mousedown', function (e) {
        e.preventDefault();

        const overlay = document.createElement('div');
        overlay.style.position = 'fixed';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.cursor = 'ns-resize';
        overlay.style.zIndex = '10000';
        overlay.style.backgroundColor = 'transparent';
        document.body.appendChild(overlay);

        let startY = e.clientY;
        let parentHeight = outputContainer.parentElement.clientHeight;
        let startHeight = outputContainer.offsetHeight;

        const MIN_HEIGHT = 30;
        const MAX_HEIGHT = 60;

        function onMouseMove(e) {
          let dy = e.clientY - startY;
          let newHeight = startHeight - dy;
          let newHeightPercent = (newHeight / parentHeight) * 100;
          newHeightPercent = Math.max(MIN_HEIGHT, Math.min(newHeightPercent, MAX_HEIGHT));
          outputContainer.style.height = newHeightPercent + '%';
        }

        function onMouseUp() {
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
          overlay.remove();
        }

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      });




      let outputDiv = document.createElement("div");
      outputDiv.classList.add("output");
      outputDiv.setAttribute("tabindex", "0");
      outputDiv.addEventListener("keydown", (e) => {
        if (e.ctrlKey && e.key.toLowerCase() === "a") {
          e.preventDefault();
          const selection = window.getSelection();
          const range = document.createRange();
          range.selectNodeContents(outputDiv);
          selection.removeAllRanges();
          selection.addRange(range);
        }
      });
      outputContainer.appendChild(outputDiv);
      editorOutputWrapper.appendChild(outputContainer);
      let tabBar = document.getElementById("tabBar");
      let addTabBtn = document.getElementById("addTabButton");
      let addTabBtn_media = document.getElementById("addTabButton_media");
      tabBar.appendChild(tabEl);
      let tabsContainer = document.getElementById("tabsContainer");
      tabsContainer.appendChild(editorOutputWrapper);
      let editorInstance = monaco.editor.create(editorContainer, {
        language: "javascript",
        theme: darkModeFlag ? "custom-dark" : "custom-light",
        automaticLayout: true,
        tabSize: spaces,
        insertSpaces: true,
        minimap: { enabled: true },
        fontSize: 14,
        fontFamily: 'Fira Code, Consolas, "Courier New", monospace',
        fontLigatures: true,
        folding: true,
        lineNumbers: "on",
        wordWrap: "on",
        scrollbar: { verticalScrollbarSize: 8, horizontalScrollbarSize: 8 },
        contextmenu: !isMobile,
        selectionHighlight: true,
        renderIndentGuides: true,
        renderLineHighlight: "all",
        cursorStyle: "line",
        cursorBlinking: "blink",
        quickSuggestions: true,
        parameterHints: true,
        autoClosingBrackets: "always",
        autoClosingQuotes: "always",
        formatOnType: true,
        formatOnPaste: true,
        suggestOnTriggerCharacters: true,
        smoothScrolling: true,
        breadcrumbs: { enabled: true },
        fixedOverflowWidgets: true,
        folding: true,
        minimap: { enabled: !isMobile },
        scrollBeyondLastLine: false,
      });
      const inputArea = editorContainer.querySelector(".monaco-editor .inputarea");
      if (inputArea) {
        inputArea.setAttribute("autocapitalize", "off");
        inputArea.setAttribute("autocomplete", "off");
        inputArea.setAttribute("spellcheck", "false");
      }
      const domNode = editorInstance.getDomNode();
      if (isMobile) {
        initializeMobileSelection(editorInstance);
        const selectAction = editorInstance.getAction("editor.action.smartSelect.expand");
        let touchStart = null;
        let touchEnd = null;
        let eventTargetStart;
        let lastDot;
        let privousTime = null;
        let lastTapX = null;
        let lastTapY = null;

        domNode.addEventListener("touchend", (event) => {
          lastTouchY = null;
          if (isContextDragged) {
            setTimeout(() => {
              isContextDragged = false;
            }, 300);
          }
          if (becasueTouch) {
            becasueTouch = false;
            if (!editorInstance.getSelection().isEmpty()) {
              theContext.classList.remove('hidden');
            }
          }
          touchEnd = new Date().getTime();
          if (wasDragging) {
            stopAll(event);
            wasDragging = false;
            return;
          }
          if (theContext.contains(event.target)) {
            return;
          }
          if (doShow.show) {
            showContextFunc();
            showContextFunc(doShow.x, doShow.y);
            doShow.show = false;
            doShow.x = 0;
            doShow.y = 0;
          }
          if (touchEnd - touchStart > 700 && event.target === eventTargetStart && Math.abs(dragTouchX - event.changedTouches[0].clientX) < 10 && Math.abs(dragTouchY - event.changedTouches[0].clientY) < 10) {
            stopAll(event);

            const point = editorInstance.getTargetAtClientPoint(
              event.changedTouches[0].clientX,
              event.changedTouches[0].clientY
            );
            if (point.type === 7) {
              return;
            }
            editorInstance.focus();


            if (point && point.position) {
              const currentPosition = editorInstance.getPosition();
              const targetColumn = point.position.column;
              const targetLine = point.position.lineNumber;
              if (currentPosition.column !== targetColumn && currentPosition.lineNumber !== targetLine) {
                editorInstance.setPosition(point.position);
              }
            }
            selectAction.run();
          }
        }, true);
        domNode.addEventListener("touchstart", (event) => {
          touchStart = new Date().getTime();
          eventTargetStart = event.target;
          dragTouchX = event.touches[0].clientX;
          dragTouchY = event.touches[0].clientY;
          if (lastTapX && lastTapY && privousTime) {
            if (Math.abs(lastTapX - event.touches[0].clientX) < 10 && Math.abs(lastTapY - event.touches[0].clientY) < 10 && touchStart - privousTime < 300) {
              stopAll(event);
              wasDragging = true;
              editorInstance.trigger('keyboard', 'editor.action.smartSelect.expand');
              return;
            }
          }
          lastTapX = event.touches[0].clientX;
          lastTapY = event.touches[0].clientY;
          privousTime = touchStart;
        });
        function blurFocus() {
          const elem = document.activeElement
          elem.blur()
          editorInstance.focus()
        }
        domNode.addEventListener("textInput", (event) => {
          stopAll(event)
          if (event.data.length > 1 || new Date().getTime() - lastDot < 20) {
            return;
          }
          editorInstance.trigger('keyboard', 'type', { text: event.data });
          blurFocus()
          if (event.data === ".") {
            lastDot = new Date().getTime();
          }
        });
        domNode.addEventListener("keyup", stopAll);
        domNode.addEventListener("input", stopAll);
      }

      editorInstance.getModel().onDidChangeOptions((e) => {
        const tabSizeNum = editorInstance.getModel().getOptions().tabSize
        if (tabSizeNum) {
          tabSizeInput.value = tabSizeNum;
          tabSizeInput.dispatchEvent(new Event("input"));
        }
      });
      let tabObj = {
        id,
        name,
        sharedBuffer,
        view,
        tabElement: tabEl,
        editorContainer,
        outputElement: outputDiv,
        editorInstance,
        worker: null,
        editorAndOutput: editorOutputWrapper
      };
      tabs.push(tabObj);
      editorInstance.onDidChangeCursorPosition(() => {
        updateStatusPosition();
      });
      closeIcon.addEventListener("click", (e) => {
        e.stopPropagation();
        if (tabs.length === 1) {
          return;
        }
        closeTab(id);
        if (tabs.length === 1) {
          document.body.classList.add("lastTab");
        }
      });
      tabEl.addEventListener("dragstart", (ev) => {
        switchTab(id);
        ev.dataTransfer.setData("text/plain", "");
        ev.dataTransfer.effectAllowed = "move";
        draggedTabId = id;
        tabEl.classList.add("dragging");
      });
      tabEl.addEventListener("dragend", () => {
        tabEl.classList.remove("dragging");
        draggedTabId = null;
        lastDropSide = null;
        document.querySelectorAll(".tab")
          .forEach((m) => m.classList.remove("tab-drop-left", "tab-drop-right", "dragging"));
      });
      tabEl.addEventListener("dragover", (ev) => {
        ev.preventDefault();
        if (!draggedTabId || tabEl.classList.contains("dragging")) return;
        let rect = tabEl.getBoundingClientRect();
        let mid = rect.left + rect.width / 2;
        if (ev.clientX < mid) {
          tabEl.classList.add("tab-drop-left");
          tabEl.classList.remove("tab-drop-right");
          lastDropSide = "left";
        } else {
          tabEl.classList.add("tab-drop-right");
          tabEl.classList.remove("tab-drop-left");
          lastDropSide = "right";
        }
      });
      tabEl.addEventListener("dragleave", () => {
        tabEl.classList.remove("tab-drop-left", "tab-drop-right");
      });
      tabEl.addEventListener("drop", (ev) => {
        ev.preventDefault();
        tabEl.classList.remove("tab-drop-left", "tab-drop-right");
        if (!draggedTabId) return;
        reorderTabsByTab(draggedTabId, id, lastDropSide);
        lastDropSide = null;
      });
      titleSpan.addEventListener("dblclick", () => {
        makeTabTitleEditable(tabObj);
      });
      if (content !== null) {
        editorInstance.setValue(content);
      } else {
        editorInstance.setValue(`// ${name}
console.log("This is a log");
console.info("This is an info");
console.warn("This is a warning");
console.error("This is an error");
prompt("This is a prompt:");
console.log("This is a log");
console.info("This is an info");
console.warn("This is a warning");
console.error("This is an error");
prompt("This is a prompt:");
console.log("This is a log");
console.info("This is an info");
console.warn("This is a warning");
console.error("This is an error");
prompt("This is a prompt:");
console.log("This is a log");
console.info("This is an info");
console.warn("This is a warning");
console.error("This is an error");
prompt("This is a prompt:");
console.log("This is a log");
console.info("This is an info");
console.warn("This is a warning");
console.error("This is an error");
prompt("This is a prompt:");
console.log("This is a log");
console.info("This is an info");
console.warn("This is a warning");
console.error("This is an error");
prompt("This is a prompt:");
console.log("This is a log");
console.info("This is an info");
console.warn("This is a warning");
console.error("This is an error");
prompt("This is a prompt:");
console.log("This is a log");
console.info("This is an info");
console.warn("This is a warning");
console.error("This is an error");
prompt("This is a prompt:");
`);
      }
      switchTab(id);
      if (tabs.length > 1) {
        document.body.classList.remove("lastTab");
      } else {
        document.body.classList.add("lastTab");
      }
      return id;
    }
    function getUniqueTabName(baseName, tabId = null) {
      let candidate = baseName;
      let suffix = 1;
      while (tabs.some((t) =>
        t.id !== tabId && t.name.toLowerCase() === candidate.toLowerCase()
      )) {
        candidate = baseName + `(${suffix++})`;
      }
      return candidate;
    }
    function getNextTabName() {
      let max = 0;
      for (let t of tabs) {
        let match = t.name.match(/^Tab(\d+)$/);
        if (match) {
          let num = parseInt(match[1], 10);
          if (num > max) max = num;
        }
      }
      return `Tab${max + 1}`;
    }
    function switchTab(tabId) {
      if (activeTabId !== null) {
        let current = tabs.find((x) => x.id === activeTabId);
        if (current) {
          current.tabElement.classList.remove("active");
          current.editorAndOutput.classList.remove("active");
        }
      }
      let newTab = tabs.find((x) => x.id === tabId);
      if (newTab) {
        newTab.tabElement.classList.add("active");
        newTab.editorAndOutput.classList.add("active");
        activeTabId = tabId;
        updateStatusPosition();
        currentTab = newTab;
      }
    }
    function closeTab(tabId) {
      let i = tabs.findIndex((x) => x.id === tabId);
      if (i === -1) return;
      let obj = tabs[i];
      if (obj.worker) {
        obj.worker.terminate();
        obj.worker = null;
      }
      obj.tabElement.remove();
      obj.editorAndOutput.remove();
      tabs.splice(i, 1);
      if (activeTabId === tabId) {
        if (tabs.length > 0) {
          switchTab(tabs[tabs.length - 1].id);
        } else {
          activeTabId = null;
        }
      }
    }
    async function handlePrompt(message, defaultValue, tab) {
      return new Promise((resolve) => {
        let container = tab.outputElement;
        let pl = document.createElement("div");
        pl.classList.add("prompt-line", "outputContent");

        let flexContainer = document.createElement("div");
        flexContainer.classList.add("flexContainer");

        let symbolDiv = document.createElement("div");
        symbolDiv.classList.add("dontAllowSelect", "symbolDiv");
        symbolDiv.textContent = `[?]`;

        let messageDiv = document.createElement("div");
        messageDiv.textContent = message;
        messageDiv.classList.add("outputItem")

        flexContainer.appendChild(symbolDiv);
        flexContainer.appendChild(messageDiv);
        pl.appendChild(flexContainer);

        let inp = document.createElement("input");
        inp.type = "text";
        inp.autocomplete = "off";
        inp.classList.add("promptInput");
        if (defaultValue) {
          inp.value = defaultValue;
        }
        inp.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            let val = inp.value.trim();
            inp.disabled = true;
            inp.style.border = "none";
            inp.style.backgroundColor = "transparent";
            if (currentTab.groupStack && currentTab.groupStack.length > 0) {
              let newContainer = currentTab.groupStack[currentTab.groupStack.length - 1];
              pl.style.marginLeft = (currentTab.groupStack.length * 20) + "px";
              newContainer.appendChild(pl);
            }
            inp.style.height = pl.clientHeight + "px";
            let te = new TextEncoder();
            let encoded = te.encode(val + "\0");
            let respBuffer = new Uint8Array(tab.sharedBuffer, 4);
            respBuffer.fill(0);
            respBuffer.set(encoded);
            Atomics.store(tab.view, 0, 1);
            Atomics.notify(tab.view, 0);
            resolve();
          }
        });
        pl.appendChild(inp);
        container.appendChild(pl);
        inp.style.height = pl.clientHeight + "px";
        inp.focus();
      });
    }

    async function handleAlert(message, tab) {
      return new Promise((resolve) => {
        let container = tab.outputElement;
        const alertLine = document.createElement("div");
        alertLine.classList.add("prompt-line", "outputContent");

        let flexContainer = document.createElement("div");
        flexContainer.classList.add("flexContainer");

        let symbolDiv = document.createElement("div", "symbolDiv");
        symbolDiv.classList.add("dontAllowSelect");
        symbolDiv.textContent = `[!]`;

        let messageDiv = document.createElement("div");
        messageDiv.textContent = message;
        messageDiv.classList.add("outputItem")

        flexContainer.appendChild(symbolDiv);
        flexContainer.appendChild(messageDiv);
        alertLine.appendChild(flexContainer);

        const okBtn = document.createElement("button");
        okBtn.classList.add("vs-button");
        okBtn.style.marginLeft = "10px";
        okBtn.textContent = "OK";
        alertLine.appendChild(okBtn);

        container.appendChild(alertLine);
        okBtn.focus();
        okBtn.addEventListener("click", () => {
          Atomics.store(tab.view, 0, 1);
          Atomics.notify(tab.view, 0);
          if (currentTab.groupStack && currentTab.groupStack.length > 0) {
            let newContainer = currentTab.groupStack[currentTab.groupStack.length - 1];
            alertLine.style.marginLeft = (currentTab.groupStack.length * 20) + "px";
            newContainer.appendChild(alertLine);
          }
          appendToOutput(container, "info", message);
          alertLine.remove();
          resolve();
        });
      });
    }




    async function runTab() {
      let btn = document.getElementById("runButton");
      btn.disabled = true;
      let tab = tabs.find((x) => x.id === currentTab.id);
      if (!tab) {
        btn.disabled = false;
        return;
      }
      try {
        clearConsole(tab.outputElement);
        if (tab.worker) {
          tab.worker.terminate();
          tab.worker = null;
        }
        await cacheWorkerCode();
        tab.groupStack = [];
        let w;
        if (!nextWorker) {
          w = new Worker(workerPath);
        } else {
          w = nextWorker;
          nextWorker = null;
        }
        tab.worker = w;
        w.onmessage = async (e) => {
          let type = e.data.type;
          let msg = e.data.message;

          if (!currentTab.groupStack) {
            currentTab.groupStack = [];
          }

          if (type === "group") {
            const details = document.createElement("details");
            details.open = !e.data.collapsed;
            const summary = document.createElement("summary");
            summary.style.display = "-webkit-box"
            if (typeof msg === "string") {
              summary.textContent = msg;
            } else if (typeof msg === "object") {
              let actualMsg = "";
              let subMsgDiv
              for (let key in msg) {
                subMsgDiv = document.createElement("div");
                if (msg[key][1]) {
                  subMsgDiv = lazyRenderTreeNode(null, msg[key][0])
                  subMsgDiv.style.marginRight = "8px";
                  summary.appendChild(subMsgDiv);
                } else {
                  subMsgDiv = document.createElement("div");
                  subMsgDiv.style.marginRight = "8px";
                  subMsgDiv.innerText = msg[key][0]
                  summary.appendChild(subMsgDiv);
                }
              }
            }
            details.appendChild(summary);
            let parentContainer = currentTab.groupStack.length > 0 ?
              currentTab.groupStack[currentTab.groupStack.length - 1] :
              currentTab.outputElement;
            parentContainer.appendChild(details);
            const groupLevel = currentTab.groupStack.length;
            details.style.marginLeft = groupLevel ? "20px" : "4px";
            currentTab.groupStack.push(details);
          }
          else if (type === "groupEnd") {
            if (currentTab.groupStack && currentTab.groupStack.length > 0) {
              currentTab.groupStack.pop();
            }
          }

          else if (type === "prompt") {
            await handlePrompt(msg, e.data.default, tab);
          }
          else if (type === "alert") {
            await handleAlert(msg, tab);
          }
          else if (type === "clear") {
            clearConsole(tab.outputElement);
          }
          else if (type === "table") {
            appendTable(tab.outputElement, e.data, msg);
          }
          else if (["log", "error", "warn", "info"].includes(type)) {
            const isForce = e.data.forceUse;
            appendToOutput(tab.outputElement, type, msg, isForce);
          }
          else if (type === "dir") {
            appendDir(tab.outputElement, msg);
          }
        }

        w.onerror = (err) => {
          appendToOutput(tab.outputElement, "error", err.message);
          if (flexSwitchCheckDefault.checked) {
            appendToOutput(tab.outputElement, "log",
              "The script has finished running with exit code 1.", true);
          }
        };
        let code = tab.editorInstance.getValue();
        w.postMessage({
          type: "execute",
          code,
          sharedBuffer: tab.sharedBuffer,
          flexSwitchCheckDefault: flexSwitchCheckDefault.checked
        });
      }
      catch (ex) {
        appendToOutput(tab.outputElement, "error", ex.message);
        appendToOutput(tab.outputElement, "log",
          "The script has finished running with exit code 1.", true);
      }
      btn.disabled = false;
      nextWorker = new Worker(workerPath);
    }
    function clearConsole(outputDiv) {
      outputDiv.innerHTML = "";
    }

    function appendDir(outputDiv, obj) {
      let container = outputDiv;
      if (currentTab.groupStack && currentTab.groupStack.length > 0) {
        container = currentTab.groupStack[currentTab.groupStack.length - 1];
      }
      let line = document.createElement("div");
      line.classList.add("outputContent");
      const groupLevel = currentTab.groupStack ? currentTab.groupStack.length : 0;
      line.style.marginLeft = groupLevel ? "20px" : "4px";
      let styleClass = (darkModeFlag ? "dark-" : "light-") + "log";
      line.classList.add(styleClass);
      line.innerHTML = obj;
      container.appendChild(line);
      container.scrollTop = container.scrollHeight;
    }

    function escapeHtmlVisible(text) {
      return text.replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;')
        .replace(/\n/g, '\\n');
    }



    function lazyRenderTreeNode(key, tree) {
      if (typeof tree !== 'object' || tree === null) {
        const div = document.createElement('div');
        let content = '';
        if (typeof tree === 'string') {
          content = `<span class="objinsp objinsp-highlight-string">${escapeHtmlVisible(tree)}</span>`;
        } else if (typeof tree === 'number') {
          content = `<span class="objinsp objinsp-highlight-number">${tree}</span>`;
        } else {
          content = `<span class="objinsp objinsp-highlight-primitive">${tree}</span>`;
        }
        if (key !== null && key !== undefined) {

          div.innerHTML = `<div class="objinsp"><span class="objinsp-highlight-key"> ${key}: </span>${content}</div>`;
        } else {
          div.innerHTML = content;
        }
        return div;
      }

      let summaryText = "";
      let childrenTree = null;
      if (key !== null) {
        summaryText = key;
        childrenTree = tree;
      } else {
        const keys = Object.keys(tree);
        if (keys.length > 0) {
          summaryText = keys[0];
          childrenTree = tree[keys[0]];
        } else {
          summaryText = "{}";
          childrenTree = {};
        }
      }
      if (key && summaryText.includes(":")) {
        const both = summaryText.split(":");
        summaryText = both[0];
        summaryText += `:<span class="objinsp objinsp-highlight-value">${both[1]}</span>`;
      }
      const detailsEl = document.createElement('details');
      detailsEl.setAttribute('data-loaded', 'false');
      const summaryEl = document.createElement('summary');
      summaryEl.className = 'objinsp objinsp-summary';
      summaryEl.innerHTML = `<span class="objinsp objinsp-highlight-type">${summaryText}</span>`;
      detailsEl.appendChild(summaryEl);

      detailsEl.addEventListener('toggle', function () {
        if (detailsEl.open && detailsEl.getAttribute('data-loaded') === 'false') {
          const container = document.createElement('div');
          container.className = 'objinsp-node';
          const childKeys = Object.keys(childrenTree);
          childKeys.forEach(function (childKey) {
            const childNode = lazyRenderTreeNode(childKey, childrenTree[childKey]);
            container.appendChild(childNode);
          });
          detailsEl.appendChild(container);
          detailsEl.setAttribute('data-loaded', 'true');
        }
      });
      return detailsEl;
    }

    function gotoLine(lineNumber) {
      const model = currentTab.editorInstance.getModel();
      if (lineNumber > model.getLineCount()) {
        return;
      }
      const column = model.getLineMaxColumn(lineNumber);
      currentTab.editorInstance.setPosition({ lineNumber, column });
      currentTab.editorInstance.revealLineInCenter(lineNumber);
      currentTab.editorInstance.focus();
    }
    const symbolsMap = { log: ">", error: "x", warn: "!", info: "i", prompt: "?" };

    function appendToOutput(outputDiv, type, message, forceUse = false) {
      let container = outputDiv;
      if (currentTab.groupStack && currentTab.groupStack.length > 0 && !forceUse) {
        container = currentTab.groupStack[currentTab.groupStack.length - 1];
      }
      let line = document.createElement('div');
      line.classList.add('outputContent');
      const groupLevel = currentTab.groupStack ? currentTab.groupStack.length : 0;
      line.style.marginLeft = groupLevel ? '20px' : '4px';
      line.classList.add(type);

      let flexContainer = document.createElement('div');
      flexContainer.classList.add('flexContainer');

      let symbolDiv = document.createElement('div');
      symbolDiv.classList.add('dontAllowSelect', 'symbolDiv');
      symbolDiv.textContent = `[${symbolsMap[type]}]`;

      let messageDiv = document.createElement('div');
      messageDiv.classList.add('outputItem');

      if (type === 'error' && forceUse) {
        const lines = message.split('\n');
        messageDiv.innerHTML = `<div>${lines[0]}\n<div style="margin-left: 20px;">${lines.slice(1).join('\n')}</div></div>`;
        const matches = message.match(/\(js:\d+\)/g);
        if (matches) {
          matches.forEach(match => {
            const lineNumber = parseInt(match.match(/\d+/)[0]);
            messageDiv.innerHTML = messageDiv.innerHTML.replace(
              match,
              `<span class="error-line handPointer" onclick="gotoLine(${lineNumber})">${match}</span>`
            );
          });
        }
      } else if (Array.isArray(message)) {
        message.forEach(segment => {
          if (segment.isObject) {
            const objDiv = lazyRenderTreeNode(null, segment.object);
            objDiv.style.marginRight = '8px';
            messageDiv.appendChild(objDiv);
          } else {
            const span = document.createElement('span');
            span.textContent = segment.text;
            if (segment.styles && segment.styles.length) {
              span.style.cssText = segment.styles.join('; ');
            }
            span.style.marginRight = '8px';
            messageDiv.appendChild(span);
          }
        });
      } else {
        messageDiv.textContent = message;
      }

      flexContainer.appendChild(symbolDiv);
      flexContainer.appendChild(messageDiv);
      line.appendChild(flexContainer);

      container.appendChild(line);
      container.scrollTop = container.scrollHeight;
    }

    function appendTable(outputElement, tableInfo, msg) {
      let container = outputElement;
      if (currentTab.groupStack && currentTab.groupStack.length > 0) {
        container = currentTab.groupStack[currentTab.groupStack.length - 1];
      }

      let tableData, headerOrder;
      if (
        tableInfo.table &&
        typeof tableInfo.table === "object" &&
        "tableData" in tableInfo.table &&
        "headerOrder" in tableInfo.table
      ) {
        tableData = tableInfo.table.tableData;
        headerOrder = tableInfo.table.headerOrder;
      } else if (tableInfo.table && typeof tableInfo.table === "object") {
        tableData = tableInfo.table;
        headerOrder = Object.keys(tableData);
        headerOrder.sort((a, b) => (a === "(index)" ? -1 : b === "(index)" ? 1 : 0));
      } else {
        appendToOutput(container, "error", "Invalid table data received.");
        return;
      }

      if (
        !tableData ||
        !Array.isArray(tableData["(index)"]) ||
        headerOrder.length === 0 ||
        tableData["(index)"].length === 0
      ) {
        appendToOutput(container, "log", "");
        return;
      }

      const rowCount = tableData["(index)"].length;
      const div = document.createElement("div");
      div.classList.add("outputContent");
      const groupLevel = currentTab.groupStack ? currentTab.groupStack.length : 0;
      div.style.marginLeft = groupLevel ? "20px" : "4px";

      const table = document.createElement("table");
      table.classList.add("console-table");

      const thead = document.createElement("thead");
      const headRow = document.createElement("tr");
      headRow.classList.add("console-table-row");
      headerOrder.forEach(col => {
        const th = document.createElement("th");
        th.classList.add("console-table-header");
        th.textContent = col;
        headRow.appendChild(th);
      });
      thead.appendChild(headRow);
      table.appendChild(thead);

      const tbody = document.createElement("tbody");
      for (let i = 0; i < rowCount; i++) {
        const tr = document.createElement("tr");
        tr.classList.add("console-table-row");
        headerOrder.forEach(col => {
          const td = document.createElement("td");
          td.classList.add("console-table-data");

          let value = tableData[col] && tableData[col][i];
          if (typeof value === "object" && value !== null) {
            if (Array.isArray(value)) {
              td.textContent = `[Array(${value.length})]`;
            } else if (value === "[Circular]") {
              td.textContent = "{…}";
            } else {
              const expandable = document.createElement("span");
              expandable.classList.add("expandable");
              expandable.textContent = "{…}";
              expandable.style.cursor = "pointer";
              expandable.addEventListener("click", () => {
                if (expandable.classList.contains("expanded")) {
                  expandable.classList.remove("expanded");
                  const details = td.querySelector(".expandable-details");
                  if (details) details.remove();
                } else {
                  expandable.classList.add("expanded");
                  const details = document.createElement("div");
                  details.classList.add("expandable-details");
                  details.style.marginTop = "4px";
                  details.style.marginLeft = "20px";
                  details.innerHTML = objectToHTML(value, 1);
                  td.appendChild(details);
                }
              });
              td.appendChild(expandable);
            }
          } else if (typeof value === "function") {
            td.textContent = value;
          } else {
            td.textContent = (value === "undefined") ? "undefined" : String(value);
          }
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);

      const symbolDiv = document.createElement("div");
      symbolDiv.classList.add("dontAllowSelect");
      symbolDiv.innerHTML = "[>]";
      table.style.marginLeft = "7px";
      symbolDiv.style.marginTop = "7px";
      div.appendChild(symbolDiv);
      const wrapBoth = document.createElement("div");
      wrapBoth.style.display = "block"
      wrapBoth.style.width = "100%"
      const wrapTable = document.createElement("div");
      wrapTable.style.display = "flex";
      wrapTable.appendChild(table);
      wrapBoth.style.width = "100%";
      wrapBoth.appendChild(wrapTable);
      div.appendChild(wrapBoth);
      let actualMsg = "";
      let subMsgDiv
      for (let key in msg) {
        subMsgDiv = document.createElement("div");
        if (msg[key][1]) {
          subMsgDiv = lazyRenderTreeNode(null, msg[key][0])
          subMsgDiv.style.marginRight = "8px";
          wrapBoth.appendChild(subMsgDiv);
        } else {
          subMsgDiv = document.createElement("div");
          subMsgDiv.style.marginRight = "8px";
          subMsgDiv.innerText = msg[key][0]
          wrapBoth.appendChild(subMsgDiv);
        }
      }
      container.appendChild(div);
      container.scrollTop = container.scrollHeight;
    }


    function objectToHTML(obj, level = 0) {
      if (obj === null) {
        return `<span style="opacity:0.7;">null</span>`;
      }
      if (typeof obj !== "object") {
        return `<span>${escapeHtml(String(obj))}</span>`;
      }
      if (Array.isArray(obj)) {
        let html = `<details open style="margin-left:${level * 20}px;">`;
        html += `<summary>Array(${obj.length})</summary>`;
        obj.forEach((value, i) => {
          html += `<div style="margin-left:${(level + 1) * 20}px;">[${i}] => ${objectToHTML(value, level + 1)}</div>`;
        });
        html += `</details>`;
        return html;
      }
      const keys = Object.keys(obj);
      let html = `<details open style="margin-left:${level * 20}px;">`;
      html += `<summary>Object {${keys.length} keys}</summary>`;
      keys.forEach((key) => {
        html += `<div style="margin-left:${(level + 1) * 20}px;">
          <strong>${escapeHtml(key)}</strong>:
          ${objectToHTML(obj[key], level + 1)}
        </div>`;
      });
      html += `</details>`;
      return html;
    }
    function escapeHtml(str) {
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;");
    }
    require.config({
      paths: {
        vs: "https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.52.2/min/vs"
      }
    });
    window.MonacoEnvironment = {
      getWorkerUrl: function () {
        return "data:text/javascript;charset=utf-8," + encodeURIComponent(`
          self.MonacoEnvironment={baseUrl:'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.52.2/min/'};
          importScripts('https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.52.2/min/vs/base/worker/workerMain.js');
        `);
      }
    };
    async function cacheWorkerCode() {
      if (!workerBlobURL) {
        let resp = await fetch(workerPath);
        let code = await resp.text();
        let blob = new Blob([code], { type: "application/javascript" });
        workerBlobURL = URL.createObjectURL(blob);
      }
    }
    require(["vs/editor/editor.main"], function () {
      monaco.languages.setMonarchTokensProvider('javascript', {
        defaultToken: 'invalid',
        tokenPostfix: '.js',

        keywords: [
          'break', 'case', 'catch', 'class', 'continue', 'debugger',
          'default', 'do', 'else', 'export', 'extends', 'finally',
          'for', 'from', 'get', 'if', 'import', 'in', 'set', 'super',
          'switch', 'symbol', 'this', 'throw', 'try', 'while', 'with',
          'yield', 'await', 'of'
        ],

        specialKeywords: [
          'let', 'const', 'var', 'function',
          'null', 'undefined', 'true', 'false', 'void', 'typeof',
          'new', 'delete', 'instanceof'
        ],

        typeKeywords: [
          'any', 'boolean', 'number', 'object', 'string', 'undefined'
        ],

        operators: [
          '<=', '>=', '==', '!=', '===', '!==', '=>', '+', '-', '**',
          '*', '/', '%', '++', '--', '<<', '</', '>>', '>>>', '&',
          '|', '^', '!', '~', '&&', '||', '?', ':', '=', '+=', '-=',
          '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=',
          '^=', '@'
        ],

        symbols: /[=><!~?:&|+\-*\/\^%]+/,
        escapes: /\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,
        digits: /\d+(_+\d+)*/,
        octaldigits: /[0-7]+(_+[0-7]+)*/,
        binarydigits: /[0-1]+(_+[0-1]+)*/,
        hexdigits: /[0-9a-fA-F]+(_+[0-9a-fA-F]+)*/,
        regexpctl: /[(){}\[\]\$\^|\-*+?\.]/,
        regexpesc: /\\(?:[bBdDfnrstvwWn0\\\/]|@regexpctl|c[A-Z]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4})/,

        tokenizer: {
          root: [
            [/[{}]/, 'delimiter.bracket'],
            { include: 'common' }
          ],

          common: [
            [/=>/, 'arrow'],

            [/\basync(?=\s+function\b)/, 'special.keyword'],

            [/(\.)([a-z_$][\w$]*)(?=\s*\()/, ['delimiter', 'method']],
            [/([a-z_$][\w$]*)(?=\s*\()/, 'method'],
            [/(\.)([a-z_$][\w$]*)/, ['delimiter', 'attribute']],

            [/[a-z_$][\w$]*/, {
              cases: {
                '@specialKeywords': 'special.keyword',
                '@keywords': 'keyword',
                '@typeKeywords': 'keyword',
                '@default': 'identifier'
              }
            }],
            [/[A-Z][\w\$]*/, 'type.identifier'],

            { include: '@whitespace' },

            [/\/(?=([^\\\/]|\\.)+\/([gimsuy]*)(\s*)(\.|;|\/|,|\)|\]|\}|$))/, { token: 'regexp', bracket: '@open', next: '@regexp' }],

            [/[()\[\]]/, '@brackets'],
            [/[<>](?!@symbols)/, '@brackets'],
            [/@symbols/, {
              cases: {
                '@operators': 'delimiter',
                '@default': ''
              }
            }],

            [/(@digits)[eE]([\-+]?(@digits))?/, 'number.float'],
            [/(@digits)\.(@digits)([eE][\-+]?(@digits))?/, 'number.float'],
            [/0[xX](@hexdigits)/, 'number.hex'],
            [/0[oO]?(@octaldigits)/, 'number.octal'],
            [/0[bB](@binarydigits)/, 'number.binary'],
            [/(@digits)/, 'number'],

            [/[;,.]/, 'delimiter'],

            [/"([^"\\]|\\.)*$/, 'string.invalid'],
            [/'([^'\\]|\\.)*$/, 'string.invalid'],
            [/"/, 'string', '@string_double'],
            [/'/, 'string', '@string_single'],
            [/`/, 'string', '@string_backtick']
          ],

          whitespace: [
            [/[ \t\r\n]+/, ''],
            [/\/\*\*(?!\/)/, 'comment.doc', '@jsdoc'],
            [/\/\*/, 'comment', '@comment'],
            [/\/\/.*$/, 'comment']
          ],

          comment: [
            [/[^\/*]+/, 'comment'],
            [/\*\//, 'comment', '@pop'],
            [/[\/*]/, 'comment']
          ],

          jsdoc: [
            [/[^\/*]+/, 'comment.doc'],
            [/\*\//, 'comment.doc', '@pop'],
            [/[\/*]/, 'comment.doc']
          ],

          regexp: [
            [/(\{)(\d+(?:,\d*)?)(\})/, ['regexp.escape.control', 'regexp.escape.control', 'regexp.escape.control']],
            [/(\[)(\^?)(?=(?:[^\]\\\/]|\\.)+)/, ['regexp.escape.control', { token: 'regexp.escape.control', next: '@regexrange' }]],
            [/(\()(\?:|\?=|\?!)/, ['regexp.escape.control', 'regexp.escape.control']],
            [/[()]/, 'regexp.escape.control'],
            [/@regexpctl/, 'regexp.escape.control'],
            [/[^\\\/]/, 'regexp'],
            [/@regexpesc/, 'regexp.escape'],
            [/\\\./, 'regexp.invalid'],
            [/(\/)([gimsuy]*)/, [{ token: 'regexp', bracket: '@close', next: '@pop' }, 'keyword.other']]
          ],

          regexrange: [
            [/-/, 'regexp.escape.control'],
            [/\^/, 'regexp.invalid'],
            [/@regexpesc/, 'regexp.escape'],
            [/[^\]]/, 'regexp'],
            [/\]/, { token: 'regexp.escape.control', next: '@pop', bracket: '@close' }]
          ],

          string_double: [
            [/[^\\"]+/, 'string'],
            [/@escapes/, 'string.escape'],
            [/\\./, 'string.escape.invalid'],
            [/"/, 'string', '@pop']
          ],

          string_single: [
            [/[^\\']+/, 'string'],
            [/@escapes/, 'string.escape'],
            [/\\./, 'string.escape.invalid'],
            [/'/, 'string', '@pop']
          ],

          string_backtick: [
            [/\$\{/, { token: 'delimiter.bracket', next: '@bracketCounting' }],
            [/[^\\`$]+/, 'string'],
            [/@escapes/, 'string.escape'],
            [/\\./, 'string.escape.invalid'],
            [/`/, 'string', '@pop']
          ],

          bracketCounting: [
            [/\{/, 'delimiter.bracket', '@bracketCounting'],
            [/\}/, 'delimiter.bracket', '@pop'],
            { include: 'common' }
          ]
        }
      });

      monaco.editor.defineTheme('custom-dark', {
        base: 'vs-dark',
        inherit: true,
        rules: [
          { token: 'special.keyword', foreground: '569cd6' },
          { token: 'keyword', foreground: 'c586c0' },
          { token: 'identifier', foreground: '9CDCFE' },
          { token: 'delimiter', foreground: 'D4D4D4' },
          { token: 'operator', foreground: 'D4D4D4' },
          { token: 'method', foreground: 'dcdcaa' },
          { token: 'attribute', foreground: '9cdcfe' },
          { token: 'arrow', foreground: '569cd6' },
          { token: 'type.identifier', foreground: '4EC9B0' },
          { token: 'function', foreground: 'dcdcaa' },
          { token: 'comment', foreground: '6A9955' },
          { token: 'string', foreground: 'CE9178' },
          { token: 'number', foreground: 'B5CEA8' },
          { token: 'regexp', foreground: 'D16969' },
          { token: 'string.escape', foreground: 'd7ba7d' },
          { token: 'string.escape.invalid', foreground: 'ffffff', background: 'e51400' },
          { token: 'string.escape.js', foreground: 'd7ba7d' },
        ],
        colors: {
          'editor.background': '#1E1E1E'
        }
      });

      monaco.editor.defineTheme('custom-light', {
        base: 'vs',
        inherit: true,
        rules: [
          { token: 'special.keyword', foreground: '0000FF' },
          { token: 'keyword', foreground: 'af00db' },
          { token: 'identifier', foreground: '0070c1' },
          { token: 'attribute', foreground: '001080' },
          { token: 'delimiter', foreground: '000000' },
          { token: 'operator', foreground: '000000' },
          { token: 'arrow', foreground: '0000FF' },
          { token: 'method', foreground: '795e26' },
          { token: 'function', foreground: '795e26' },
          { token: 'type.identifier', foreground: '267f99' },
          { token: 'comment', foreground: '008000' },
          { token: 'string', foreground: 'a31515' },
          { token: 'string.escape', foreground: 'a31515' },
          { token: 'string.escape.invalid', foreground: 'ffffff', background: 'e51400' },
          { token: 'string.escape.js', foreground: 'ee0000' },
          { token: 'number', foreground: '098658' },
          { token: 'regexp', foreground: 'd16969' }
        ],
        colors: {
          'editor.background': '#ffffff',
          'editor.foreground': '#333333'
        }
      });
      loadSettings();
      createTab();
    });

    function updateStatusPosition() {
      if (activeTabId === null) {
        document.getElementById("statusPosition").textContent = "Ln 0, Col 0";
        return;
      }
      let t = tabs.find((x) => x.id === activeTabId);
      if (!t) return;
      let pos = t.editorInstance.getPosition();
      if (pos) {
        document.getElementById("statusPosition").textContent = `Ln ${pos.lineNumber}, Col ${pos.column}`;
      }
    }
    document.getElementById('addTabButton').addEventListener("click", () => {
      createTab();
    });
    document.getElementById('addTabButton_media').addEventListener("click", () => {
      createTab();
    });
    document.getElementById("tabBar").addEventListener("click", (e) => {
      let clickedTab = tabs.find((t) =>
        t.tabElement === e.target || t.tabElement.contains(e.target)
      );
      if (clickedTab) {
        switchTab(clickedTab.id);
      }
    });
    ["gitIcon", "settingsIcon", "exportIcon"].forEach((iconId) => {
      let el = document.getElementById(iconId);
      el.addEventListener("click", (e) => {
        let alreadyActive = e.currentTarget.classList.contains("active");
        document.querySelectorAll(".icon")
          .forEach((b) => b.classList.remove("active"));
        document.querySelectorAll(".sidebar-panel")
          .forEach((p) => p.classList.remove("active"));
        if (!alreadyActive) {
          e.currentTarget.classList.add("active");
          let targetPanel = e.currentTarget.getAttribute("data-target");
          document.getElementById(targetPanel).classList.add("active");
        }
      });
    });
    document.getElementById("searchIcon").addEventListener("click", () => {
      if (activeTabId === null) return;
      let t = tabs.find((x) => x.id === activeTabId);
      if (!t) return;
      if (isMobile) {
        document.querySelectorAll(".sidebar-panel")
          .forEach((p) => p.classList.remove("active"));
        document.querySelectorAll(".icon")
          .forEach((b) => b.classList.remove("active"));

      }
      t.editorInstance.getAction("actions.find").run();
    });
    document.addEventListener("click", (event) => {
      if (!event.target.closest(".vs-navbar-item")) {
        closeDropdowns();
        activeDropdown = null;
      }
    });
    document.querySelectorAll(".vs-navbar-item").forEach((item) => {
      item.addEventListener("click", (evt) => {
        let dropdownId = evt.currentTarget.getAttribute("data-dropdown");
        let dd = document.getElementById(dropdownId);
        document.querySelectorAll(".vs-navbar-dropdown")
          .forEach((d) => d.classList.remove("active"));
        if (dd) {
          dd.classList.toggle("active");
          activeDropdown = dd.classList.contains("active") ? dd : null;
        }
      });
      item.addEventListener("mouseover", (evt) => {
        if (activeDropdown) {
          let dropdownId = evt.currentTarget.getAttribute("data-dropdown");
          let dd = document.getElementById(dropdownId);
          if (activeDropdown !== dd) {
            activeDropdown.classList.remove("active");
            dd.classList.add("active");
            activeDropdown = dd;
          }
        }
      });
    });
    tabSizeInput.addEventListener("input", () => {
      spaces = parseInt(tabSizeInput.value, 10);
      tabSizeDisplay.textContent = spaces;
      document.getElementById("statusSpaces").textContent = `Spaces: ${spaces}`;
      tabs.forEach((t) => {
        t.editorInstance.updateOptions({ tabSize: spaces });
      });
    });
    let redoBtn = document.getElementById("redoBtn");
    let undoBtn = document.getElementById("undoBtn");
    function toggleDisabled(el, disabled) {
      if (disabled) {
        el.classList.add("disabled");
        el.style.color = "grey";
        el.style.cursor = "default";
      } else {
        el.classList.remove("disabled");
        el.style.cursor = "pointer";
        if (darkModeFlag) {
          el.style.color = "white";
        } else {
          el.style.color = "black";
        }
      }
    }
    function updateUndoRedoButtons() {
      if (activeTabId === null) {
        toggleDisabled(undoBtn, true);
        toggleDisabled(redoBtn, true);
        return;
      }
      let t = tabs.find((x) => x.id === activeTabId);
      if (!t) return;
      let model = t.editorInstance.getModel();
      if (!model) return;
      toggleDisabled(undoBtn, !model.canUndo());
      toggleDisabled(redoBtn, !model.canRedo());
    }
    document.addEventListener("keydown", (e) => {
      if (e.ctrlKey && e.key === "s") {
        e.preventDefault();
        document.getElementById("saveScriptBtn")
          .dispatchEvent(new MouseEvent("click"));
      } else if ((e.ctrlKey && e.key === "z") ||
        (e.ctrlKey && e.shiftKey && e.key === "Z")) {
        setTimeout(() => updateUndoRedoButtons(), 100);
      }
    });
    redoBtn.addEventListener("click", () => {
      if (activeTabId === null) return;
      let t = tabs.find((x) => x.id === activeTabId);
      t.editorInstance.trigger("redo", "redo", null);
      updateUndoRedoButtons();
    });
    undoBtn.addEventListener("click", () => {
      if (activeTabId === null) return;
      let t = tabs.find((x) => x.id === activeTabId);
      t.editorInstance.trigger("undo", "undo", null);
      updateUndoRedoButtons();
    });
    setInterval(() => updateUndoRedoButtons(), 500);
    document.getElementById("uploadFileBtn").addEventListener("click", () => {
      let input = document.createElement("input");
      input.type = "file";
      input.accept = ".js";
      input.style.display = "none";
      input.addEventListener("change", async (e) => {
        let file = e.target.files[0];
        let reader = new FileReader();
        reader.onload = (evt) => {
          let newTabName = getUniqueTabName(file.name);
          createTab(newTabName, evt.target.result);
          closeDropdowns();
        };
        reader.readAsText(file);
      });
      document.body.appendChild(input);
      input.click();
      input.remove();
    });
    document.getElementById("saveScriptBtn").addEventListener("click", () => {
      if (activeTabId === null) return;
      let t = tabs.find((x) => x.id === activeTabId);
      let content = t.editorInstance.getValue();
      let blob = new Blob([content], { type: "text/javascript" });
      let url = URL.createObjectURL(blob);
      let a = document.createElement("a");
      a.href = url;
      a.download = t.name.endsWith(".js") ? t.name : (t.name + ".js");
      a.click();
      URL.revokeObjectURL(url);
      closeDropdowns();
    });
    function closeDropdowns() {
      setTimeout(() => {
        activeDropdown = null;
        document.querySelectorAll(".vs-navbar-dropdown")
          .forEach((d) => d.classList.remove("active"));
        document.querySelectorAll(".vs-navbar-item")
          .forEach((i) => i.classList.remove("active"));
      }, 100);
    }
    let gitInp = document.getElementById("gitUrl");
    let loadGitButton = document.getElementById("loadGitButton");
    gitInp.addEventListener("keydown", (e) => {
      if (e.key === "Enter") loadGitButton.click();
    });
    gitInp.addEventListener("input", () => {
      if (!gitInp.value.trim()) {
        loadGitButton.disabled = true;
      } else {
        loadGitButton.disabled = false;
      }
    });
    loadGitButton.addEventListener("click", async () => {
      let urlVal = gitInp.value.trim();
      if (!urlVal) return;
      let fileName = "untitled.js";
      try {
        new URL(urlVal);
      } catch (e) {
        showAlert("Invalid URL");
        return;
      }
      let normalized = normalizeUrl(urlVal);
      let parsed = parseGitHubUrl(normalized);
      if (parsed.isRawFile) {
        let slashIdx = parsed.rawUrl.lastIndexOf("/");
        if (slashIdx !== -1) {
          fileName = parsed.rawUrl.substring(slashIdx + 1);
        }
      } else if (parsed.isFile) {
        let slashIdx = parsed.path.lastIndexOf("/");
        if (slashIdx !== -1) {
          fileName = parsed.path.substring(slashIdx + 1);
        }
      }
      try {
        let fileContent;
        if (parsed.isRawFile) {
          fileContent = await fetchRawFile(parsed.rawUrl);
        } else if (parsed.isFile) {
          let fileData = await fetchFromGit(parsed.owner, parsed.repo, parsed.path, parsed.branch);
          if (!fileData.content) {
            showAlert("Failed to fetch file content.");
            return;
          }
          fileContent = atob(fileData.content);
        } else {
          showAlert("Invalid GitHub file URL. Must point to a specific file.");
          return;
        }
        createTab(fileName, fileContent);
      } catch (err) {
        showAlert(`Error fetching file: ${err.message}`);
      }
    });
    function normalizeUrl(u) {
      if (u.endsWith(".git")) {
        u = u.slice(0, -4);
      }
      if (!u.startsWith("http://") && !u.startsWith("https://")) {
        u = "https://" + u;
      }
      if (u.startsWith("http://")) {
        u = "https://" + u.substring(7);
      }
      return u;
    }
    function parseGitHubUrl(u) {
      if (u.includes("raw.githubusercontent.com")) {
        let match = u.match(/^https:\/\/raw\.githubusercontent\.com\/([^\/]+)\/([^\/]+)\/([^\/]+)\/(.+)$/);
        if (match) {
          return { isRawFile: true, rawUrl: u };
        }
        return { isRawFile: false };
      }
      let m = u.match(/^https:\/\/github\.com\/([^\/]+)\/([^\/]+)\/blob\/([^\/]+)\/(.+)$/);
      if (!m) return { isFile: false };
      return {
        owner: m[1],
        repo: m[2],
        branch: m[3],
        path: m[4],
        isFile: true
      };
    }
    async function fetchFromGit(owner, repo, path, branch = "main") {
      let apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${branch}`;
      let resp = await fetch(apiUrl);
      if (!resp.ok) {
        throw new Error(`Failed to fetch file: ${resp.statusText}`);
      }
      let data = await resp.json();
      if (data.type !== "file") {
        throw new Error("The URL does not point to a valid file.");
      }
      return data;
    }
    async function fetchRawFile(rawUrl) {
      let r = await fetch(rawUrl);
      if (!r.ok) {
        throw new Error(`Failed to fetch raw file: ${r.statusText}`);
      }
      return await r.text();
    }
    function makeTabTitleEditable(tabObj) {
      let span = tabObj.tabElement.querySelector(".tab-title");
      let closeIcon = tabObj.tabElement.querySelector(".close");
      if (!span) return;
      closeIcon.style.display = "none";
      let oldName = tabObj.name;
      let input = document.createElement("input");
      input.type = "text";
      input.value = oldName;
      input.classList.add("tab-title-edit");
      tabObj.tabElement.replaceChild(input, span);
      input.focus();
      input.select();
      let done = false;
      let finalize = () => {
        if (done) return;
        done = true;
        let newVal = input.value.trim();
        if (!newVal || newVal === oldName) {
          newVal = oldName;
        } else {
          newVal = getUniqueTabName(newVal, tabObj.id);
        }
        tabObj.name = newVal;
        let newSpan = document.createElement("span");
        newSpan.classList.add("tab-title");
        newSpan.textContent = newVal;
        newSpan.addEventListener("dblclick", () => {
          makeTabTitleEditable(tabObj);
        });
        tabObj.tabElement.replaceChild(newSpan, input);
        closeIcon.style.display = "block";
      };
      input.addEventListener("blur", finalize);
      input.addEventListener("keydown", (evt) => {
        if (evt.key === "Enter") {
          evt.preventDefault();
          finalize();
        } else if (evt.key === "Escape") {
          evt.preventDefault();
          input.value = oldName;
          finalize();
        }
      });
    }

    function arrayBufferToBase64(buffer) {
      let binary = '';
      const bytes = new Uint8Array(buffer);
      const chunkSize = 0x8000;
      for (let i = 0; i < bytes.length; i += chunkSize) {
        binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
      }
      return window.btoa(binary);
    }

    document.addEventListener("DOMContentLoaded", async function () {
      await cacheWorkerCode();
      nextWorker = new Worker(workerBlobURL);
    });


    function exportCode() {
      switch (exportSelect.value) {
        case "allZip":
          exportAllZip();
          break;
        case "image":
          exportImage();
          break;
        case "pdf":
          exportPDF();
          break;
        case "current":
          exportCurrent();
          break;
      }
    }

    function exportAllZip() {
      if (tabs.length === 0) {
        return;
      }
      if (tabs.length === 1) {
        exportCurrent();
        return;
      }

      exportModalContent.innerHTML = "";

      let checklistContainer = document.createElement("div");
      checklistContainer.style.display = "flex";
      checklistContainer.style.flexWrap = "wrap";
      checklistContainer.style.gap = "10px";
      checklistContainer.style.padding = "10px";

      tabs.forEach((tab) => {
        let checkboxWrapper = document.createElement("div");
        checkboxWrapper.style.display = "flex";
        checkboxWrapper.style.alignItems = "center";
        checkboxWrapper.style.flex = "1 0 auto";

        let checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = true;
        checkbox.id = "export-tab-" + tab.id;
        checkbox.dataset.tabId = tab.id;

        let label = document.createElement("label");
        label.htmlFor = checkbox.id;
        label.textContent = tab.name;
        label.style.marginLeft = "5px";

        checkboxWrapper.appendChild(checkbox);
        checkboxWrapper.appendChild(label);
        checklistContainer.appendChild(checkboxWrapper);
      });
      exportModalContent.appendChild(checklistContainer);

      let exportBtn = document.createElement("button");
      exportBtn.textContent = "Export";
      exportBtn.classList.add("exportBtn");
      exportBtn.style.marginTop = "20px";

      function updateExportButtonState() {
        let selectedCount = checklistContainer.querySelectorAll("input[type='checkbox']:checked").length;
        exportBtn.disabled = selectedCount === 0;
      }

      checklistContainer.querySelectorAll("input[type='checkbox']").forEach((cb) => {
        cb.addEventListener("change", updateExportButtonState);
      });
      updateExportButtonState();

      exportModalContent.appendChild(exportBtn);

      exportBtn.addEventListener("click", function () {
        let selectedCheckboxes = checklistContainer.querySelectorAll("input[type='checkbox']:checked");
        let selectedTabs = [];
        selectedCheckboxes.forEach((cb) => {
          let tabId = parseInt(cb.dataset.tabId, 10);
          let tabObj = tabs.find((t) => t.id === tabId);
          if (tabObj) {
            selectedTabs.push(tabObj);
          }
        });
        closeModal("close");

        if (selectedTabs.length === 0) {
          return;
        }

        if (selectedTabs.length === 1) {
          let t = selectedTabs[0];
          let blob = new Blob([t.editorInstance.getValue()], { type: "text/javascript" });
          let url = URL.createObjectURL(blob);
          let a = document.createElement("a");
          a.href = url;
          a.download = t.name.endsWith(".js") ? t.name : t.name + ".js";
          a.click();
          URL.revokeObjectURL(url);
        } else {
          let zip = new JSZip();
          selectedTabs.forEach((t) => {
            let fileName = t.name.endsWith(".js") ? t.name : t.name + ".js";
            zip.file(fileName, t.editorInstance.getValue());
          });
          zip.generateAsync({ type: "blob" }).then((content) => {
            let a = document.createElement("a");
            a.href = URL.createObjectURL(content);
            a.download = "scripts.zip";
            a.click();
          });
        }
      });

      displayModal();
    }

    if (!window.customQuillFormatsRegistered) {
      const Size = Quill.import('attributors/style/size');
      Size.whitelist = ['8px', '12px', '16px', '20px', '24px', '36px', '48px', '72px'];
      Quill.register(Size, true);

      const Font = Quill.import('attributors/style/font');
      Font.whitelist = ['arial', 'times-new-roman', 'courier-new'];
      Quill.register(Font, true);

      window.customQuillFormatsRegistered = true;
    }

    const quillToolbarOptions = [
      ['bold', 'italic', 'underline'],
      [{ 'size': ['8px', '12px', '16px', '20px', '24px', '36px', '48px', '72px'] }],
      [{ 'color': [] }],
      [{ 'font': ['arial', 'times-new-roman', 'courier-new'] }],
      [{ 'align': [] }],
      [{ "direction": "rtl" }],
    ];

    function initQuil(quilInstance) {
      quilInstance.format('bold', false);
      quilInstance.format('italic', false);
      quilInstance.format('underline', false);
      quilInstance.format('color', darkModeFlag ? '#ffffff' : '#000000');
      quilInstance.format('font', 'arial');
      quilInstance.format('align', 'left');
      quilInstance.getModule('toolbar').container.querySelector('span.ql-size span.ql-picker-options span.ql-picker-item[data-value="16px"]').click()
    }

    async function takeImage(domElem) {
      const canvas = await html2canvas(domElem, {
        scale: 2,
        logging: false,
        backgroundColor: null,
        willReadFrequently: true,
        allowTaint: true,
        useCORS: true
      });
      return canvas.toDataURL("image/png");
    }

    async function getOutputDivClone() {
      const backgroundColor = darkModeFlag ? '#1E1E1E' : '#FFFFFF';
      const maxWidth = currentTab.editorInstance.getLayoutInfo().contentWidth + "px";
      const outputWrapper = document.createElement('div');
      outputWrapper.classList.add("outputContainer", "isClone", darkModeFlag ? "darkMode" : "lightMode");
      outputWrapper.style.backgroundColor = backgroundColor;
      const tempOutputDiv = currentTab.outputElement.cloneNode(true);
      outputWrapper.appendChild(tempOutputDiv);
      tempOutputDiv.classList.add(...currentTab.outputElement.classList);
      tempOutputDiv.style.width = maxWidth;
      tempOutputDiv.style.maxWidth = maxWidth;
      tempOutputDiv.style.height = 'auto';
      tempOutputDiv.style.overflowY = 'visible';
      return outputWrapper;
    }

    async function getEditorDiv() {
      const model = currentTab.editorInstance.getModel();
      const code = model.getValue();
      const language = "javascript";
      const codeLines = code.split('\n');
      const highlightedLines = await Promise.all(
        codeLines.map((line) => monaco.editor.colorize(line, language, {}))
      );
      const fontSize = currentTab.editorInstance.getOption(monaco.editor.EditorOption.fontSize) || 14;
      const lineHeight = currentTab.editorInstance.getOption(monaco.editor.EditorOption.lineHeight) || 20;
      const fontFamily = currentTab.editorInstance.getOption(monaco.editor.EditorOption.fontFamily) || 'Fira Code, monospace';
      const backgroundColor = darkModeFlag ? '#1E1E1E' : '#FFFFFF';
      const textColor = darkModeFlag ? '#D4D4D4' : '#000000';
      const wrapperDiv = document.createElement('div');
      wrapperDiv.style.backgroundColor = backgroundColor;
      wrapperDiv.style.fontFamily = fontFamily;
      wrapperDiv.style.fontSize = `${fontSize}px`;
      wrapperDiv.style.lineHeight = `${lineHeight}px`;
      wrapperDiv.style.whiteSpace = "pre-wrap";
      wrapperDiv.style.width = '100%';
      wrapperDiv.style.color = textColor;
      document.addEventListener('DOMContentLoaded', function () {
        if (window.screen.width < 768) {
          wrapperDiv.style.transform = "scale(0.7)";
          showAlert("Please note that the code may not be displayed properly on small screens.");
        }
      });
      codeLines.forEach((line, index) => {
        const lineWrapper = document.createElement('div');
        lineWrapper.style.display = "flex";
        lineWrapper.style.alignItems = "flex-start";
        const lineNumberDiv = document.createElement('div');
        lineNumberDiv.classList.add(darkModeFlag ? "lineNumDark" : "lineNumLight", "lineNum", "numberDiv");
        lineNumberDiv.textContent = index + 1;
        const codeLineDiv = document.createElement('div');
        codeLineDiv.classList.add("codeLineDiv");
        codeLineDiv.innerHTML = highlightedLines[index] || '';
        lineWrapper.appendChild(lineNumberDiv);
        lineWrapper.appendChild(codeLineDiv);
        wrapperDiv.appendChild(lineWrapper);
      });
      return wrapperDiv;
    }

    async function exportImage() {
      const wrapperBoth = document.createElement('div');
      wrapperBoth.style.position = 'relative';
      wrapperBoth.style.paddingTop = '1px';
      wrapperBoth.style.backgroundColor = darkModeFlag ? '#1E1E1E' : '#FFFFFF';

      const editorTextDiv = document.createElement('div');
      editorTextDiv.id = 'editorText';
      editorTextDiv.style.border = darkModeFlag ? '1px solid #333' : '1px solid #c0c0c0';
      editorTextDiv.style.color = darkModeFlag ? '#fff' : '#000000';
      wrapperBoth.appendChild(editorTextDiv);

      const editorQuill = new Quill(editorTextDiv, {
        theme: 'snow',
        placeholder: 'Enter your text here...',
        modules: { toolbar: quillToolbarOptions }
      });
      const editorToolbar = editorTextDiv.querySelector('.ql-toolbar');
      editorToolbar.id = 'editorRichTextToolbar';
      function repositionToolbar(toolbar, element) {
        const elementRect = element.getBoundingClientRect();
        const containerRect = wrapperBoth.getBoundingClientRect();
        toolbar.style.top = (elementRect.top - containerRect.top - toolbar.offsetHeight) + 'px';
        toolbar.style.left = (elementRect.left - containerRect.left) + 'px';
      }
      repositionToolbar(editorToolbar, editorTextDiv);
      setTimeout(() => { initQuil(editorQuill); }, 200);
      const editorDiv = await getEditorDiv();
      wrapperBoth.appendChild(editorDiv);

      const exportBtnsWrapper = document.createElement('div');
      exportBtnsWrapper.classList.add("exportBtnsWrapper");

      let outputToolbar, outputQuill;
      if (currentTab.outputElement.innerHTML.trim()) {
        const outputTextDiv = document.createElement('div');
        outputTextDiv.id = 'outputText';
        outputTextDiv.style.border = darkModeFlag ? '1px solid #333' : '1px solid #c0c0c0';
        outputTextDiv.style.color = darkModeFlag ? '#fff' : '#000000';
        wrapperBoth.appendChild(outputTextDiv);

        outputQuill = new Quill(outputTextDiv, {
          theme: 'snow',
          placeholder: 'Enter your text here...',
          modules: { toolbar: quillToolbarOptions }
        });
        outputToolbar = outputTextDiv.querySelector('.ql-toolbar');
        outputToolbar.id = 'outputRichTextToolbar';
        if (darkModeFlag) {
          outputToolbar.style.background = '#333';
          outputToolbar.style.borderColor = '#555';
          outputToolbar.style.color = '#fff';
          outputToolbar.querySelectorAll('button').forEach(button => button.style.color = '#c5c5c5');
          outputToolbar.querySelectorAll('select').forEach(select => {
            select.style.backgroundColor = '#555';
            select.style.color = '#fff';
            select.style.border = '1px solid #777';
          });
        } else {
          outputToolbar.style.background = '#f0f0f0';
          outputToolbar.style.borderColor = '#ccc';
          outputToolbar.style.color = '#000';
          outputToolbar.querySelectorAll('button').forEach(button => button.style.color = '#000');
          outputToolbar.querySelectorAll('select').forEach(select => {
            select.style.backgroundColor = '#fff';
            select.style.color = '#000';
            select.style.border = '1px solid #ccc';
          });
        }
        repositionToolbar(outputToolbar, outputTextDiv);
        setTimeout(() => { initQuil(outputQuill); }, 200);
        const outputClone = await getOutputDivClone();
        outputClone.style.backgroundColor = darkModeFlag ? '#1E1E1E' : '#FFFFFF';
        wrapperBoth.appendChild(outputClone);
        const headerTextCheckbox = document.createElement("input");
        headerTextCheckbox.type = "checkbox";
        headerTextCheckbox.classList.add("exportCheckbox");
        exportBtnsWrapper.appendChild(headerTextCheckbox);
        headerTextCheckbox.checked = true;
        headerTextCheckbox.addEventListener("change", () => {
          outputTextDiv.style.display = headerTextCheckbox.checked ? "block" : "none";
        });
        const exportCheckbox = document.createElement("input");
        exportCheckbox.type = "checkbox";
        exportCheckbox.classList.add("exportCheckbox");
        exportBtnsWrapper.appendChild(exportCheckbox);
        exportCheckbox.checked = true;
        exportCheckbox.addEventListener("change", () => {
          outputClone.style.display = exportCheckbox.checked ? "block" : "none";
          headerTextCheckbox.style.visibility = exportCheckbox.checked ? "visible" : "hidden";
        });
      }

      const editorHeaderCheckbox = document.createElement("input");
      editorHeaderCheckbox.type = "checkbox";
      editorHeaderCheckbox.classList.add("exportCheckbox");
      exportBtnsWrapper.appendChild(editorHeaderCheckbox);
      editorHeaderCheckbox.checked = true;
      editorHeaderCheckbox.addEventListener("change", () => {
        editorTextDiv.style.display = editorHeaderCheckbox.checked ? "block" : "none";
      });

      exportModalContent.appendChild(wrapperBoth);
      exportModalContent.appendChild(exportBtnsWrapper);
      const exportBtn = document.createElement('button');
      exportBtn.textContent = "Export Image";
      exportBtn.classList.add("exportBtn");
      exportBtnsWrapper.appendChild(exportBtn);
      exportBtn.onclick = async function () {
        exportBtn.disabled = true;
        editorToolbar.style.display = 'none';
        if (outputToolbar) {
          outputToolbar.style.display = 'none';
        }
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const imgSrc = await takeImage(wrapperBoth);
        closeModal("close");
        const bothImg = new Image();
        bothImg.src = imgSrc;
        let theyReady = false;
        bothImg.onload = () => { theyReady = true; };
        while (!theyReady) {
          await new Promise(resolve => setTimeout(resolve, 150));
        }
        canvas.width = bothImg.width;
        canvas.height = bothImg.height;
        ctx.drawImage(bothImg, 0, 0);
        const a = document.createElement('a');
        a.href = canvas.toDataURL("image/png");
        a.download = `${currentTab.name}.png`;
        a.click();
      };
      displayModal();
    }

    async function exportPDF() {
      const editorDiv = await getEditorDiv();
      const wrapBoth = document.createElement('div');
      wrapBoth.style.position = 'relative';
      wrapBoth.style.paddingTop = '1px';
      wrapBoth.style.backgroundColor = darkModeFlag ? '#1E1E1E' : '#FFFFFF';
      const editorTextDiv = document.createElement('div');
      editorTextDiv.id = 'editorText';
      editorTextDiv.style.border = darkModeFlag ? '1px solid #333' : '1px solid #c0c0c0';
      editorTextDiv.style.color = darkModeFlag ? '#fff' : '#000000';
      wrapBoth.appendChild(editorTextDiv);
      const editorQuill = new Quill(editorTextDiv, {
        theme: 'snow',
        placeholder: 'Enter your text here...',
        modules: { toolbar: quillToolbarOptions }
      });
      const editorToolbar = editorTextDiv.querySelector('.ql-toolbar');
      editorToolbar.id = 'editorRichTextToolbar';
      function repositionToolbar(toolbar, element) {
        const elementRect = element.getBoundingClientRect();
        const containerRect = wrapBoth.getBoundingClientRect();
        toolbar.style.top = (elementRect.top - containerRect.top - toolbar.offsetHeight) + 'px';
        toolbar.style.left = (elementRect.left - containerRect.left) + 'px';
      }
      repositionToolbar(editorToolbar, editorTextDiv);
      setTimeout(() => { initQuil(editorQuill); }, 200);
      wrapBoth.appendChild(editorDiv);
      const exportBtnsWrapper = document.createElement('div');
      exportBtnsWrapper.classList.add("exportBtnsWrapper");
      let outputToolbar, outputQuill;
      if (currentTab.outputElement.innerHTML.trim()) {
        const outputTextDiv = document.createElement('div');
        outputTextDiv.id = 'outputText';
        outputTextDiv.style.border = darkModeFlag ? '1px solid #333' : '1px solid #c0c0c0';
        outputTextDiv.style.color = darkModeFlag ? '#fff' : '#000000';
        wrapBoth.appendChild(outputTextDiv);
        outputQuill = new Quill(outputTextDiv, {
          theme: 'snow',
          placeholder: 'Enter your text here...',
          modules: { toolbar: quillToolbarOptions }
        });
        outputToolbar = outputTextDiv.querySelector('.ql-toolbar');
        outputToolbar.id = 'outputRichTextToolbar';
        if (darkModeFlag) {
          outputToolbar.style.background = '#333';
          outputToolbar.style.borderColor = '#555';
          outputToolbar.style.color = '#fff';
          outputToolbar.querySelectorAll('button').forEach(button => button.style.color = '#c5c5c5');
          outputToolbar.querySelectorAll('select').forEach(select => {
            select.style.backgroundColor = '#555';
            select.style.color = '#fff';
            select.style.border = '1px solid #777';
          });
        } else {
          outputToolbar.style.background = '#f0f0f0';
          outputToolbar.style.borderColor = '#ccc';
          outputToolbar.style.color = '#000';
          outputToolbar.querySelectorAll('button').forEach(button => button.style.color = '#000');
          outputToolbar.querySelectorAll('select').forEach(select => {
            select.style.backgroundColor = '#fff';
            select.style.color = '#000';
            select.style.border = '1px solid #ccc';
          });
        }
        repositionToolbar(outputToolbar, outputTextDiv);
        setTimeout(() => { initQuil(outputQuill); }, 200);
        const outputClone = await getOutputDivClone();
        outputClone.style.backgroundColor = darkModeFlag ? '#1E1E1E' : '#FFFFFF';
        wrapBoth.appendChild(outputClone);
        const headerTextCheckbox = document.createElement("input");
        headerTextCheckbox.type = "checkbox";
        headerTextCheckbox.classList.add("exportCheckbox");
        exportBtnsWrapper.appendChild(headerTextCheckbox);
        headerTextCheckbox.checked = true;
        headerTextCheckbox.addEventListener("change", () => {
          outputTextDiv.style.display = headerTextCheckbox.checked ? "block" : "none";
        });
        const exportCheckbox = document.createElement("input");
        exportCheckbox.type = "checkbox";
        exportCheckbox.classList.add("exportCheckbox");
        exportBtnsWrapper.appendChild(exportCheckbox);
        exportCheckbox.checked = true;
        exportCheckbox.addEventListener("change", () => {
          outputClone.style.display = exportCheckbox.checked ? "block" : "none";
          headerTextCheckbox.style.visibility = exportCheckbox.checked ? "visible" : "hidden";
        });
      }
      const editorHeaderCheckbox = document.createElement("input");
      editorHeaderCheckbox.type = "checkbox";
      editorHeaderCheckbox.classList.add("exportCheckbox");
      exportBtnsWrapper.appendChild(editorHeaderCheckbox);
      editorHeaderCheckbox.checked = true;
      editorHeaderCheckbox.addEventListener("change", () => {
        editorTextDiv.style.display = editorHeaderCheckbox.checked ? "block" : "none";
      });
      exportModalContent.appendChild(wrapBoth);
      exportModalContent.appendChild(exportBtnsWrapper);
      const exportBtn = document.createElement('button');
      exportBtn.textContent = "Export PDF";
      exportBtn.classList.add("exportBtn");
      exportBtnsWrapper.appendChild(exportBtn);
      exportBtn.onclick = async function () {
        exportBtn.disabled = true;
        editorToolbar.style.display = 'none';
        if (outputToolbar) { outputToolbar.style.display = 'none'; }
        const contentWidth = wrapBoth.offsetWidth;
        const contentHeight = wrapBoth.offsetHeight;
        let doc = new jsPDF({
          orientation: contentWidth > contentHeight ? 'l' : 'p',
          unit: 'px',
          format: [contentWidth, contentHeight]
        });
        await new Promise(resolve => {
          doc.html(wrapBoth, {
            callback: resolve,
            x: 0,
            y: 0,
            margin: [0, 0, 0, 0],
            html2canvas: { scale: 1, logging: false }
          });
        });
        closeModal("close");
        if (doc.internal.getNumberOfPages() > 1) {
          for (let i = doc.internal.getNumberOfPages(); i > 1; i--) {
            doc.deletePage(i);
          }
        }
        doc.save(`${currentTab.name}.pdf`);
      };
      displayModal();
    }


    function exportCurrent() {
      if (activeTabId === null) {
        return;
      }
      let t = tabs.find((x) => x.id === activeTabId);
      let blob = new Blob([t.editorInstance.getValue()], { type: "text/javascript" });
      let url = URL.createObjectURL(blob);
      let a = document.createElement("a");
      a.href = url;
      a.download = t.name.endsWith(".js") ? t.name : (t.name + ".js");
      a.click();
      URL.revokeObjectURL(url);
    }

    function displayModal() {
      modal.classList.add("active");
      modal.dispatchEvent(new Event("modalOpened"));
    }

    function closeModal(event) {
      if (event.target === modal || event === "close") {
        modal.classList.remove("active");
        modal.dispatchEvent(new Event("modalClosed"));
      }
    }

    function showAlert(message) {
      exportModalContent.innerHTML = "";
      const wrapBoth = document.createElement('div');
      wrapBoth.classList.add("alertWrap");
      let alertDiv = document.createElement("div");
      alertDiv.classList.add("alertText");
      alertDiv.textContent = message;
      const btn = document.createElement("button");
      btn.textContent = "Close";
      btn.classList.add("exportBtn");
      btn.addEventListener("click", () => {
        closeModal("close");
      });
      wrapBoth.appendChild(alertDiv);
      wrapBoth.appendChild(btn);
      exportModalContent.appendChild(wrapBoth);
      displayModal();
    }

    modal.addEventListener("modalOpened", () => {
      document.addEventListener("click", closeModal);
    });
    modal.addEventListener("modalClosed", () => {
      document.removeEventListener("click", closeModal);
      exportModalContent.innerHTML = "";
    });

    function modalIsOpen() {
      return modal.classList.contains("active");
    }

    function rgbToHex(rgb) {
      const match = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
      if (!match) return rgb;
      return "#" + [match[1], match[2], match[3]].map(x => parseInt(x).toString(16).padStart(2, '0')).join('');
    }

    const getEventNames = (root) => {
      let events = [];
      const objectHasSubPrototype = (object, comp) => {
        let proto = Object.getPrototypeOf(object);
        while (proto !== null && proto !== EventTarget) {
          proto = Object.getPrototypeOf(proto);
        }
        return (proto !== null);
      };
      const addEventNames = (propNames) => {
        propNames.filter(x => x.match(/^on\w+$/)).forEach((propName) => {
          propName = propName.substr(2);
          if (events.indexOf(propName) === -1) {
            events.push(propName);
          }
        });
      };
      Object.getOwnPropertyNames(root).forEach((name) => {
        let value = root[name];
        if (value) {
          if (objectHasSubPrototype(value, EventTarget)) {
            let propNames = Object.getOwnPropertyNames(Object.getPrototypeOf(value).prototype);
            addEventNames(propNames);
            propNames = Object.getOwnPropertyNames(window);
            addEventNames(propNames);
          }
        }
      });
      return events;
    };

    function focusTab(tabElem) {
      if (!tabElem) { tabElem = currentTab; }
      tabElem.editorInstance.focus();
    }

    document.getElementById("selectAllBtn").addEventListener("click", () => {
      const range = currentTab.editorInstance.getModel().getFullModelRange();
      currentTab.editorInstance.setSelection(range);
      focusTab();
      closeDropdowns();
    });



  </script>

</body>

</html>